<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D.TopZ</title>
  
  <subtitle>青春猪头好少年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://deletee.top/"/>
  <updated>2019-12-01T13:26:40.746Z</updated>
  <id>http://deletee.top/</id>
  
  <author>
    <name>deletee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据50问-第2问：如何理解数据中台</title>
    <link href="http://deletee.top/2019/12/01/bigdata-50FAQ-02/"/>
    <id>http://deletee.top/2019/12/01/bigdata-50FAQ-02/</id>
    <published>2019-12-01T07:05:30.000Z</published>
    <updated>2019-12-01T13:26:40.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Q2:如何理解数据中台？</p></blockquote><p>​        突然火爆了概念词”数据中台“，说实话，一听到这词以为某些互联网大佬又在吹概念了， 中台的概念一热，很多似是而非的东西都在往中台的概念上凑，一下子出现很多中台，如业务中台、数据中台、技术中台、算法中台、移动中台等等。特别是很多原来称作平台的，现在也都摇身一变成了中台，赶时髦。那么我们如何理解数据中台？我们提出如下几个问题：</p><blockquote><ul><li>什么是数据中台？</li><li>数据中台与数据仓库有什么不一样？</li><li>数据中台的价值是什么？</li><li>如何建设数据中台？</li></ul></blockquote><a id="more"></a><p>​        为了回答上述问题，我们先看看业界各互联网公司是如何定义数据中台以及如何实施业务中台的。</p><h4 id="0x1-数据中台建设实践"><a href="#0x1-数据中台建设实践" class="headerlink" title="0x1 数据中台建设实践"></a>0x1 数据中台建设实践</h4><h5 id="0x11-小米数据中台建设实践"><a href="#0x11-小米数据中台建设实践" class="headerlink" title="0x11 小米数据中台建设实践"></a>0x11 小米数据中台建设实践</h5><p><strong>小米的三大中台建设：</strong> <strong>业务+数据+技术</strong></p><p>​        小米参考了业界优秀的案例包括移动中台、数据中台、业务中台、技术中台等，再结合其业务发展历程及业务现状，整理了中台架构的核心方法论，一是企业如何共享服务，二是如何为业务提供便利。</p><p>​        小米认为数据中台是数字化转型的核心，在建设数据中台之前，小米面对的三大难题：</p><ul><li><p><strong>数据极度分散：</strong>数据分散在各个业务系统中，没有统一的数据共享池，也就是没有数据仓库（数据湖），业务分析，数据应用通常从数据底层进行数据抽取。</p></li><li><p><strong>数据指标混乱：</strong>没有良好的数据治理，从而也会造成指标混乱，业务系统各自为战形成数据孤岛，指标口径自然是很难做到统一。</p></li><li><p><strong>数据工具量少：</strong>需要一站式的访问入口、可视化和交互性更强的数据展示方式、支持移动端访问。</p></li></ul><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/sqibwUCydDhz1vatAUOJXP2Sx9R4zkMZhUcFAYDCibicaqibYqCVmKhapyP6iasjY6C23C0ibzaD4ws6pb0XDMEw0KJg/640?mprfK=https%3A%2F%2Fmp.weixin.qq.com%2F" alt="img"></p><p>​        小米建设数据中台旨在建立数据精细化管理体系，<strong>小米想从业务端沉淀数据，在共享到X DATA大数据分析，然后发现问题在反馈到业务系统中解决问题。</strong></p><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/sqibwUCydDhz1vatAUOJXP2Sx9R4zkMZhG9LRawUEcCJvrZGicUZ1AyWAiblLVpd4OPNHPIACZ833yX11Cqn6ArOA/640?mprfK=https%3A%2F%2Fmp.weixin.qq.com%2F" alt="img"></p><p>在数据中台上还需要运用一些关键技术，包括：大数据离线计算、趋势预测、实时计算、自然语言处理、可视化分析、图像识别等。<strong>小米数据中台对业务运营产生的价值，主要体现在生产监控、日常运营、经营管理、战略管控等方面。</strong></p><h5 id="0x12-京东数据中台建设"><a href="#0x12-京东数据中台建设" class="headerlink" title="0x12 京东数据中台建设"></a>0x12 京东数据中台建设</h5><p><strong>数据中台：破除企业数据孤岛</strong></p><p>​        在企业业务发展过程中所累积的大量数据，往往分散在各个业务单元和组织内部，形成一个个”数据孤岛”、”数据烟囱”。而数据中台是着眼于企业数据资产汇集、数据算法迭代、数据能力输出的根基平台，以数据指引业务决策并驱动业务增长，是破除数据孤岛的关键策略。</p><p>​        京东数据中台负责人—黎科峰介绍，目前京东集团已形成零售、数科、物流、保险、健康等多元化的业务格局，各业务都进入到精细化运营阶段，对于数据精细化运营提出了更高的需求。京东过往十多年业务发展沉淀下来的海量数据，需要通过数据中台的建设形成宝贵的数据资产，以打造强有力的数据智能能力。这也是京东自去年就开始推动数据中台建设的重要原因。</p><p>​        黎科峰认为，数据中台的核心包括数据基础层、数据服务层、数据应用层。除了技术之外，数据中台建设更重要的是一种协作意识和组织能力。因此京东在建设数据中台的过程中提出了共建、共享、标准化三个关键理念。京东数据中台的共建理念，就是要联合各个业务单元，共同打造沉淀一套大数据中台。共享则是要避免数据孤岛，<strong>打破组织界限</strong>，<strong>实现数据的共通、能力共享</strong>。而标准则是指统一的数据标准，从底层的数据治理标准、数据口径标准，到统一的数据标签体系和数据模型服务，确保数据在集团内部流转和应用是基于同样的标准和基础。</p><p>​        首先在数据底层的建设方面，京东建立了统一的采存算大数据平台，有节奏地合并数据集市，形成统一的大集市。</p><p>​        在数据服务层，京东正在搭建一套公共的数据标签体系，汇聚前台业务部门、运营部门以及广告、搜索等各个垂直场景的标签数据，不断迭代，为各个数据应用场景赋能。同时，数据中台向各数据应用层提供数据模型能力，通过商品数据治理形成更准确的商品画像。</p><p>​        在数据应用层，京东数据中台推动前台统一了数十个数据产品，建立了统一的数据口径和数据看板。前台部门统一通过黄金眼和商智来提供对采销和商家的数据报表服务，底层通过数据中台使用同一套数据。</p><p>​        经过多年的积累，京东的亿万消费者和商家在平台上沉淀了海量的数据，数据的深入挖掘对于提升用户体验和商家营销能力都至关重要。京东数据中台着眼于数据驱动业务精细化运营的能力建设，持续夯实数据基础，形成数据与业务正向自循环促进的关系，不仅全面推动京东内部蓬勃的业务创新，也可以更好地对外服务，带动整个产业的数字化转型。</p><h4 id="0x2-中台的定义"><a href="#0x2-中台的定义" class="headerlink" title="0x2 中台的定义"></a>0x2 中台的定义</h4><p> 中台的定义还要求以下两点：</p><ul><li><p>中台是一种共性能力组织，支持了多个业务。</p></li><li><p>中台支持的是多个前台业务。</p></li></ul><p>要定义中台，重要的是要能比较明确的区分中台和平台。中台和平台都是某种共性能力，区分两者的重点一是看是否具备业务属性，二是看是否是一种组织。中台是支持多个前台业务且具备业务属性的共性能力组织，平台是支持多个前台或中台业务且不具备业务属性的共性能力。</p><ol><li><p>（狭义的）业务中台：一般指在线业务为典型特征的中台。在OLDI（Online Data-Intensive）时代，越来越多的企业的核心业务都是在线业务，因此把在线业务中台简称为业务中台。但对那些不是以在线业务为主的企业，它需要的业务中台可能就不是在线业务中台了，而是数据中台或别的什么中台。</p></li><li><p>数据中台：一般指以数据采集、数据集成、数据治理，指标体系和数据仓库统一建设等数据管理活动为典型特征的中台。同样，在OLDI时代，数据中台越来越重要。狭义的业务中台也就是在线业务中台负责OLDI中的OL（Online），数据中台负责OLDI中的DI（Data-Intensive）。</p></li><li><p>用户中台：用户中台可以认为是一种特殊的数据中台，一般以用户ID统一、全域用户画像建设、全域会员体系建设等为典型特征。用户中台很通用，比更广义的数据中台往往更常见。很多企业没能力建设更全面的数据中台，但建设了会员中心等用户中台。</p></li><li><p>内容中台：内容中台往往也可以认为是一种特殊的数据中台，一般以内容的采买、内容爬取、内容的加工处理、内容安全保障等为典型特征。</p></li><li><p>搜索推荐中台：这两个中台比较像，因为搜索和推荐的技术比较相似。这两个中台一般是为推荐和搜索系统提供一套相对标准的工作流程，同时支持流程各环节的可定制能力，从而支持多个前端推荐搜索业务的快速开发。</p></li></ol><p>​        广义的中台都是业务中台，只不过是不同场景的细分而已，一切没有业务属性的”中台“都不能称之为中台，只是标上”中台“的概念而已。</p><h4 id="0x3-数据中台与数据仓库有什么不一样？"><a href="#0x3-数据中台与数据仓库有什么不一样？" class="headerlink" title="0x3 数据中台与数据仓库有什么不一样？"></a>0x3 数据中台与数据仓库有什么不一样？</h4><p>​        在笔者理解看来，数据中台包含了数据仓库的概念，数据中台不仅包含了数据采集，数据继承，数据计算，还包含了数据服务，数据应用。数据中台<strong>负责全域数据采集</strong>、<strong>数据资产加工和管理</strong>、并<strong>向前台业务部门和决策部门提供数据服务</strong>的，所以数据中台的核<strong>心应该是数据资产管理和数据赋能</strong>。通俗的讲就是数据弹药库。</p><p>​        数据中台是一个数据集成平台，它不仅仅是为数据分析挖掘而建，它更重要的功能是作为各个业务的数据源，为业务系统提供数据和计算服务。数据中台的本质就是“数据仓库+数据服务中间件”</p><p><img src="https://pic1.zhimg.com/80/v2-1e6a5946311b2697f76ecc913f45b638_hd.jpg" alt="img"></p><h4 id="0x4-数据中台的价值"><a href="#0x4-数据中台的价值" class="headerlink" title="0x4 数据中台的价值"></a>0x4 数据中台的价值</h4><p>​        一般提到中台，那么势必会有前台，后台的概念，前台是面向用户的终端系统，比如门户网站，手机App，微信公众号等，那么后台则是对应的账号系统，数据库系统，财务系统，供应链系统等等。准确的来说，后台是解决企业效率的问题，而中台是为了解决业务创新问题。中台链接了前台用户与后台核心资源，既可以将早已臃肿不堪的前台系统中的稳定通用业务能力“沉降”到中台层，为前台减肥，实施“大中台，小前台”战略，恢复前台的响应力。前台可以快速生成各种微应用；又可以将后台系统中需要频繁变化或是需要被前台直接使用的业务能力“提取”到中台层，赋予这些业务能力更强的灵活度和更低的变更成本，从而为前台提供更强大的“能力炮火”⽀援。</p><p>​        中台就像是在前台与后台之间添加的一组“变速齿轮”，将前台与后台的速率进行匹配，是前台与后台的桥梁。它为前台而生，易于前台使用，将后台资源顺滑流向用户，响应用户。</p><h4 id="0x5-如何建设中台"><a href="#0x5-如何建设中台" class="headerlink" title="0x5 如何建设中台"></a>0x5 如何建设中台</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Q2:如何理解数据中台？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​        突然火爆了概念词”数据中台“，说实话，一听到这词以为某些互联网大佬又在吹概念了， 中台的概念一热，很多似是而非的东西都在往中台的概念上凑，一下子出现很多中台，如业务中台、数据中台、技术中台、算法中台、移动中台等等。特别是很多原来称作平台的，现在也都摇身一变成了中台，赶时髦。那么我们如何理解数据中台？我们提出如下几个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是数据中台？&lt;/li&gt;
&lt;li&gt;数据中台与数据仓库有什么不一样？&lt;/li&gt;
&lt;li&gt;数据中台的价值是什么？&lt;/li&gt;
&lt;li&gt;如何建设数据中台？&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x1 数据仓库" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
      <category term="1x12 综合" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/1x12-%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="学习" scheme="http://deletee.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="大数据" scheme="http://deletee.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>每周一本书-《问题分析与解决》</title>
    <link href="http://deletee.top/2019/11/26/question-ana/"/>
    <id>http://deletee.top/2019/11/26/question-ana/</id>
    <published>2019-11-26T13:15:30.000Z</published>
    <updated>2019-11-26T17:08:43.575Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本周学习的一本书是《麦肯锡-问题分析与解决技巧》，恰逢今天又学习了王萃老师的《问题分析与解决》课程，这本书很好的教给我们如何提升发现和分析问题以及解决问题的能力，无论你是一般职员或是高层管理人员，无论在你在组织中担任什么职务，分析与解决问题的技术已是置身职场中不可或缺的核心能力之一。这里想把两门知识融合分享一下学习笔记。<br>​        <a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的生活或工作中，总会遇到这样或那样的问题，也会经常抱怨问题很难解决或是解决成本太高，尽管事情的紧急程度、重要程度不同，但我们身边确实存在无数的问题，例如：</p><blockquote><ul><li>公司电梯很慢</li><li>食堂的菜很难吃</li><li>A产品的形象越来越差</li><li>B酒店的空房率居高不下</li><li>如何抢回失去的市场</li><li>如何提升下季度的销售额</li><li>算法的召回率很低</li></ul></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓“问题”就是需要“被解决的课题”，在无数的“问题”中，有一个共通点，那就是我们必须决定如何拟定解决策略并付诸解决。</p><h4 id="0x1-问题的本质是期望与现状出现了落差"><a href="#0x1-问题的本质是期望与现状出现了落差" class="headerlink" title="0x1 问题的本质是期望与现状出现了落差"></a>0x1 问题的本质是期望与现状出现了落差</h4><p>​      如何理解这句话？比如：“公司的电梯很慢”，现状是公司的电梯从1楼到9楼需要5分钟，而期望电梯能够在1分钟内到达9楼，那么落差是：电梯运行速度比预期慢了4分钟；再说“食堂的菜很难吃？”，现状是：公司的菜色单一，油腻，期望的是：公司能增加菜品，减少菜品的油量，那么落差就是：菜品丰富度不够，口味油腻。</p><p><img src="/knowledge/image-20191126215709489.png" alt="image-20191027160601941" style="zoom:60%;align:center"></p><p>​        那么我们可以用现状(Current)、期待(Expect)、落差(Gap)来描述一个问题。大家可以用这个方法进行剩余问题的锻炼。</p><h4 id="0x2-问题的划分"><a href="#0x2-问题的划分" class="headerlink" title="0x2 问题的划分"></a>0x2 问题的划分</h4><p>​        通过问题的本质，我们需要将问题进行划分，根据不同类型的问题选择合适的解决策略，一般而言，问题可以区分为两种类型：（1）恢复原状型；（2）达成理想型；（3）防范潜在型。“恢复原状型”，顾名思义是指恢复成原本的状态，遇到这种类型的问题时，要将原本的状况视为期待的状态。“恢复原状型”的思考方式是，现状与过去的状况之间出现了落差，例如：</p><blockquote><ul><li>服务错误率高达80%</li><li>手表电池没电，因此不动了</li><li>采购成本最近几个月逐渐攀升</li></ul></blockquote><p>​        “达成理想型”是现状并无大碍，但是期待事情有更好的结果，解决办法为：达成理想。</p><blockquote><ul><li>明年的目标是：希望营业额有7%的增长</li><li>希望孩子能够考上重点大学</li><li>处理事务工作上，希望能够再减少3个小时</li></ul></blockquote><p>​        “防范潜在型”，这句话的意思是讲，搁置不管会发生不良状态，或是指已经出现不良状态端倪，解决思路是：如何维持现状，若以目的区分，可以视为恢复（维持）原状型问题。</p><blockquote><ul><li>已经出现了离职率上升</li><li>营业额较上个月出现了减少</li><li>服务器的水位已到达90%，并持续增长</li></ul></blockquote><p><img src="/knowledge/image-20191126222453477.png" alt="image-20191027160601941" style="zoom:60%;align:center"></p><h4 id="0x3-分析问题"><a href="#0x3-分析问题" class="headerlink" title="0x3 分析问题"></a>0x3 分析问题</h4><p>​        当我们发现和定位问题之后，很多同学的思路就是想找解决方案，由此非常容易走入一个误区，以为是找到了方法，殊不知只是发现解决的是问题表面，因为没有深刻分析问题，往往得出的解决方案耗费代价很大，由或是临时解决了问题仍然会复发。</p><p>​        分析问题的方式往往由三个因素决定了：经验+专业知识+思维模式，经验表示你可能经历过或者遇到相似的事情，能够从经验中去分析解决问题；因为专业知识不同，也会造成分析问题的思路不一，例如前面提到的“公司电梯很慢”，普通同学：错开高峰期，电梯单双限制；程序员同学：通过提升电梯的调度算法来实现优化；电梯维护人员：某个固件出现问题，需要维修，前面两个因素由个人所决定，然后思维模式是可以进行学习来提升。</p><p>​        那么，又如何进行问题分析？第一步，就是确定事情的优先级。</p><h5 id="0x31-确定事情优先级"><a href="#0x31-确定事情优先级" class="headerlink" title="0x31 确定事情优先级"></a>0x31 确定事情优先级</h5><p>​        如果我们锁定的问题或者课题很多，那么该从哪一个问题开始着手呢？很多同学“想到哪个做哪个，先行动起来比较重要”，这样的做法往往效率很差。一般而言，在分辨事情的优先级时，比较有效的方法是从“紧急性”和“重要性”两个标准下手，我们可以看下优先顺序矩阵：</p><p><img src="/knowledge/image-20191126223707135.png" alt="image-20191027160601941" style="zoom:60%;align:center"></p><p>也可以从解决事情的成本与产出的价值考虑优先级：</p><p><img src="/knowledge/image-20191126224055750.png" alt="image-20191027160601941" style="zoom:60%;align:center"></p><h5 id="0x32-收集信息，掌握事实"><a href="#0x32-收集信息，掌握事实" class="headerlink" title="0x32 收集信息，掌握事实"></a>0x32 收集信息，掌握事实</h5><p>​        如果没有掌握问题的根本原因，就会变成只对问题的表象进行处理。例如：感冒吃感冒药，但说不定是病毒感染，吃药并不能根治；公司的营业额减少，因此投入大量资金进行广告，实际情况是产品满意度差，退货率高，广告的投入可能会带来一些改善，反会造成投入产出比下降。</p><p><img src="/knowledge/image-20191126230307346.png" alt="image-20191027160601941" style="zoom:45%;align:center"></p><p>​        掌握现状与分析原因息息相关，其基础建立在对事实的掌握程度上，信息收集有很多方式：</p><blockquote><ul><li><p>现场调查/市场调研</p></li><li><p>线上系统数据收集</p></li><li><p>专家经验</p></li><li>……</li></ul></blockquote><p>​        下面分享一个实际案例：</p><p>​        杰斐逊纪念堂是一座高96英尺的白色大理石建筑，是为纪念美国第三任总统而建，在美国是极为著名的旅游景点。该纪念堂曾经遇到一个重大问题：建筑物顶部经常积满鸟粪，白色大理石墙体发生了严重脱落，严重影响了整座建筑物的安全，更不用提及对建筑物美观的影响了，如何解决这一重大问题，美国政府曾斥巨资试图解决但却未能奏效。后来请专家来对这一问题进行研究，以找到解决问题的答案。</p><p><img src="/knowledge/F9783FD044E44F1BB428AD500300D0B3.jpg" alt="image-20191027160601941" style="zoom:45%;align:center"></p><p>​        那么我们如何收集信息？当然我们无法真实的去现场进行调查，但可以设想从哪些角度去收集信息：</p><blockquote><p>四季气候</p><p>都是什么鸟类</p><p>鸟粪是否具有腐蚀性</p><p>周边是否树林较多</p><p>常规的维护工作有哪些？</p><p>是否存在恶意破坏？</p></blockquote><p>看到这里，你能想到的数据收集有哪些呢？有兴趣的同学，可以进行头脑风暴。</p><p>​        专家经过初步研究给出结论：清洁剂对墙体是有害的，清洗大理石墙体的频率与大理石墙体脱落的程度正相关，清理大理石墙体的频率越高，脱落的程度也就是越大。因此建议，减少大理石墙体的清理次数，这样就可以确保建筑物的安全了。</p><p>​        但这一结论的指导性却并不好，因为当减少或停止对大理石墙体的清理时，带来的结果是白色大理石变得非常脏，严重影响了杰斐逊纪念堂的景观。</p><h5 id="0x33-分析方法"><a href="#0x33-分析方法" class="headerlink" title="0x33 分析方法"></a>0x33 分析方法</h5><p>​        当你获取了大量事实数据后，那我们要怎样进行分析呢？王萃老师分享了三套方法，分别是：5-why、MECE以及鱼骨分析法。下面逐一进行介绍：</p><p>​        <strong>（1）5-why分析法</strong></p><p>​        5-why分析法又称5问法，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要3次，有时也许要10次。如古话所言：打破砂锅问到底。</p><p>​        例如：杰斐逊纪念堂白色大理石墙体发生了严重脱落的5why分析法如下:</p><blockquote><ul><li><p>1.为什么会频频清洗墙体？</p><p>—-建筑物顶部经常积满鸟粪。</p></li><li><p>2.为什么同处于华盛顿广场的林肯纪念堂没有鸟粪而偏偏杰斐逊纪念堂有？</p><p>—-杰斐逊纪念堂顶部有大量的蜘蛛，蜘蛛吸引大量的燕子前来觅食筑巢，从而留下了鸟粪。</p></li><li><p>3.为什么会有这些大量的蜘蛛？</p><p>—-因为建筑物顶部有某种非常多的小虫子，而这种小虫子恰恰是蜘蛛最喜欢的食物。</p></li><li><p>4.为什么会有如此多的这种虫子爬到纪念堂顶部？</p><p>——上面开着一些窗子，阳光容易从窗口射入，这些小虫子除了喜欢灰垢外，更喜欢阳光，因此它们集居顶部，并在阳光之下极速繁衍，形成了厚厚的虫子层。</p></li></ul></blockquote><p>​        当问题解答至此时，专家给出了有效的解决方案：把顶层的窗户关上。一个用巨资都无法解决的问题就这样解决了。归结起来就是这样的一个解决思路，值得管理者关注了，最终以最小的成本，有效的解决了问题。</p><p>​        <strong>但注意，</strong>大家可能陷入5why分析法理解误区，就是随意提5个问题，没有往解决问题的方向上进行提问，结果就是问题无穷无尽，然而问题仍未分析到根本原因。例如：某商场遭客人投诉</p><blockquote><ul><li><p>1.为什么商场遭客人投诉？</p><p>—-因为客人在商场滑到。</p></li><li><p>2.为什么客人会滑到？</p><p>—-商场地面有水。</p></li><li><p>3.为什么地面有水？</p><p>——因为有其他客人不小心水洒了。</p></li><li><p>4.为什么客人会不小心将水洒了</p><p>——因为客人的水杯没有杯托。</p></li><li><p>5.为什么水杯没有杯托？</p><p>因为负责提供杯托的人员请假了</p><p>….</p></li></ul></blockquote><p>​        大家从上面的问题分析的思路可以看出，问题无穷无尽但仍无法分析问题的根本原因，大家可能已经注意到，在第三个why时，就开始远离根本原因，正确的分析方法应该是：</p><blockquote><ul><li><p>1.为什么商场遭客人投诉？</p><p>  —-因为客人在商场滑到。</p></li><li><p>2.为什么客人会滑到？</p><p>  —-商场地面有水。</p></li><li><p>3.为什么地面没有人及时清理？</p><p>  ——因为负责地面清理的当值员工请假了。</p></li><li><p>4.为什么没有互备的人员？  —根因所在，因为没有互备的人员，当值人员请假，无法及时清理地面</p><hr></li></ul></blockquote><p>大家可以尝试利用<strong>5why分析法</strong>找一个问题进行分析看是否能发现问题的根本原因</p><p>​    <strong>（2）MECE分析法</strong></p><p>​        MECE的全称是“Mutually Exclusive,Collectively Exhaustive”，也就是不重复、不遗漏，通过四个步骤，面对复杂的情况和问题，也能有逻辑地、系统地分析问题、解决问题。这包括：1）定问题目的；2）寻找切入点；3）继续再细分；4）确认无遗漏<br><img src="/knowledge/image-20191126235341882.png" alt="image-20191027160601941" style="zoom:45%;align:center"></p><p>​            实际案例：基于麦肯锡MECE分析法的案例<br><img src="/knowledge/image-20191126235909514.png" alt="image-20191027160601941" style="zoom:55%;align:center"></p><p>王萃老师课程中又提供了常见的分析框架：</p><ul><li>PEST</li><li>SWOT</li><li>思考事业战略的“3C”</li></ul><p><img src="/knowledge/image-20191127000731873.png" alt="image-20191127000731873"></p><ul><li>适合业务分析的“五力”</li><li>思考组织策略的“7S”</li></ul><p><img src="/knowledge/image-20191127001001151.png" alt="image-20191027160601941" style="zoom:75%;align:center"></p><ul><li>拟定营销策略的“4P”<br><img src="/knowledge/image-20191127001153054.png" alt="image-20191127001153054"></li></ul><p>​    <strong>（3）鱼骨分析法</strong></p><p>​        鱼骨分析法，又名<a href="https://baike.baidu.com/item/因果分析法/4587680" target="_blank" rel="noopener">因果分析法</a>，是一种发现问题“根本原因”的分析方法，分析结构如下：</p><ul><li>A、针对问题点，选择层别方法；</li><li>B、按头脑风暴分别对各层别类别找出所有可能原因（因素）；</li><li>C、将找出的各要素进行归类、整理，明确其从属关系；</li><li>D、分析选取重要因素；</li><li>E、检查各要素的描述方法，确保语法简明、意思明确。</li></ul><p>如下实际为针对某电商满意度下降调查分析：</p><p><img src="/knowledge/image-20191127002435810.png" alt="image-20191027160601941" style="zoom:55%;align:center"></p><h4 id="0x4-解决问题"><a href="#0x4-解决问题" class="headerlink" title="0x4 解决问题"></a>0x4 解决问题</h4><p>​        有人曾对爱因斯坦说：“如果有人对你说：‘60分钟内如果想不出下面将要提出的问题的答案，你就会没命的。’那么你会怎么办？”爱因斯坦回答道：“前55分钟我会用来提恰当的问题。”也就是说，没有什么能比恰当的问题更能导出正确答案了。 </p><p>​        前面我们使用了大量篇幅用来解释什么是问题，怎么分析问题，可见问题发现与分析问题的重要性，书中针对不同类型的问题给出了思路：</p><p><img src="/knowledge/image-20191127003648164.png" alt="image-20191027160601941" style="zoom:55%;align:center"></p><p>​        </p><h4 id="0x5-最后的总结"><a href="#0x5-最后的总结" class="headerlink" title="0x5 最后的总结"></a>0x5 最后的总结</h4><p>​        王萃老师教给我们解决问题的一般流程：发现问题-&gt;分析原因-&gt;确定方案及可替代方案-&gt;执行方案并效果评估，我们碰到的问题都可以使用这样一套方法进行解决，当然理论是理论，实践是实践，重点是从这套方法中学习发现问题、分析原因的思维才是关键。希望这套方法能够帮助到大家能解决工作上碰到的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本周学习的一本书是《麦肯锡-问题分析与解决技巧》，恰逢今天又学习了王萃老师的《问题分析与解决》课程，这本书很好的教给我们如何提升发现和分析问题以及解决问题的能力，无论你是一般职员或是高层管理人员，无论在你在组织中担任什么职务，分析与解决问题的技术已是置身职场中不可或缺的核心能力之一。这里想把两门知识融合分享一下学习笔记。&lt;br&gt;​
    
    </summary>
    
      <category term="3x 职场篇" scheme="http://deletee.top/categories/3x-%E8%81%8C%E5%9C%BA%E7%AF%87/"/>
    
      <category term="3x2 每周一本书" scheme="http://deletee.top/categories/3x-%E8%81%8C%E5%9C%BA%E7%AF%87/3x2-%E6%AF%8F%E5%91%A8%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    
    
      <category term="职场" scheme="http://deletee.top/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>大数据50问-第1问：如何评价数据仓库</title>
    <link href="http://deletee.top/2019/11/23/bigdata-50FAQ-01/"/>
    <id>http://deletee.top/2019/11/23/bigdata-50FAQ-01/</id>
    <published>2019-11-23T14:59:30.000Z</published>
    <updated>2019-12-01T07:04:55.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Q1:如何量化评价一个数据仓库的好坏？</p></blockquote><p>​        在网上看到一篇文章关于如何评价数据仓库的，它是这样说的：数据仓库的失败率并非80%都是失败的，很多项目介于成功失败之间；数据仓库项目实施周期比较长，不容易看到成果；因为很大程度上评价成功的标准常常是在既成事实之后采取制定的，实际上大多数用户事先并不清楚自己的目标，从而对数据仓库项目的评价有失偏颇。事实上很多失败的数据仓库在某种程度上也可以看成成功的（至少可以看作介于失败与成功之间）</p><a id="more"></a><p>​        我的看法数据仓库的好坏可以当成一个问题进行分析，首先部门或者公司建设数据仓库的目标是什么？与建仓前的期待是什么？那么现状与期待的差距是什么？根据目标来评价数据仓库更为客观，而不简单的从某种价值产出角度来评价。</p><p>​        那么，我们需要哪些指标来进行评价期待与现状的差距。数据仓库的4个特征：面向主题，集成的，稳定的，反应历史的。</p><h4 id="0x1-数据整合的角度"><a href="#0x1-数据整合的角度" class="headerlink" title="0x1 数据整合的角度"></a>0x1 数据整合的角度</h4><h5 id="0x11-数据完备性：数据的整合是否消除孤岛效应？数据集成是否覆盖业务场景。"><a href="#0x11-数据完备性：数据的整合是否消除孤岛效应？数据集成是否覆盖业务场景。" class="headerlink" title="0x11 数据完备性：数据的整合是否消除孤岛效应？数据集成是否覆盖业务场景。"></a>0x11 数据完备性：数据的整合是否消除孤岛效应？数据集成是否覆盖业务场景。</h5><blockquote><ul><li>笔者经历过一些数据仓库的建设，因为涉及到一些数据权限的问题，以至于业务需求时需要应急形式的数据导入，一方面造成了数据模型的混乱，另一方面增加业务开发成本。</li></ul></blockquote><h5 id="0x12-主题合理性：是否有效的面向业务主题？主题划分是否合理？对标的是业务分析主题是否可以完整的映射到数据主题。"><a href="#0x12-主题合理性：是否有效的面向业务主题？主题划分是否合理？对标的是业务分析主题是否可以完整的映射到数据主题。" class="headerlink" title="0x12 主题合理性：是否有效的面向业务主题？主题划分是否合理？对标的是业务分析主题是否可以完整的映射到数据主题。"></a>0x12 主题合理性：是否有效的面向业务主题？主题划分是否合理？对标的是业务分析主题是否可以完整的映射到数据主题。</h5><blockquote><ul><li>主题不合理往往是对于业务没有进行深入的调研，通常以现有系统以主题划分，由此造成的结果，当业务频繁变动，数仓开发效率和维护成本非常高。</li></ul></blockquote><h5 id="0x13-模型有效性：数据模型是否支撑一类业务的数据需求，应用层取数的复杂度，是否存在跨层取数现状"><a href="#0x13-模型有效性：数据模型是否支撑一类业务的数据需求，应用层取数的复杂度，是否存在跨层取数现状" class="headerlink" title="0x13 模型有效性：数据模型是否支撑一类业务的数据需求，应用层取数的复杂度，是否存在跨层取数现状"></a>0x13 模型有效性：数据模型是否支撑一类业务的数据需求，应用层取数的复杂度，是否存在跨层取数现状</h5><blockquote><ul><li>数据仓库的好坏也由其数据模型好坏决定，通常来说，模型是可以覆盖某一类业务问题或者说支撑某一类业务分析的，如果说某一类常见的业务需求在模型中未能够支撑，需要关联大量数据表，那么这个模型是失败的。</li></ul></blockquote><h4 id="0x2-数据质量的角度"><a href="#0x2-数据质量的角度" class="headerlink" title="0x2 数据质量的角度"></a>0x2 数据质量的角度</h4><p>数据仓库的好坏也可以从数据质量的角度来评价：</p><h5 id="0x21-数据准确性：是否消除数据的不一致性，保证口径统一，命名是否规范"><a href="#0x21-数据准确性：是否消除数据的不一致性，保证口径统一，命名是否规范" class="headerlink" title="0x21 数据准确性：是否消除数据的不一致性，保证口径统一，命名是否规范"></a>0x21 数据准确性：是否消除数据的不一致性，保证口径统一，命名是否规范</h5><blockquote><ul><li><p>数据准确性这一类问题非常常见，在工作经常会碰到与业务或者运营人员沟通需求的时候，自己理解和需求得出的数据不一致。这一部分是由于对产品对业务理解的不够透彻另一方面也存在数据源口径不一致的问题，因此在做数据治理或者数据仓库标准化的实时对指标换句话说数据口径的统一显得明显重要。比如：登录量，该指标存在很大歧义，是月登录量，还是日登录量，是A系统登录量，还是B系统登录量，</p></li><li><p>建立统一指标体系，注重全面性和均衡性，覆盖业务、管理、风险、成长等各个发展战略目标，既要注重指标含义，也要注重指标挂历，完成基础指标体系的设计和定义工作，分阶段完成各类关键指标</p></li></ul><p>完整的指标至少包括如下几项要素：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">指标名称，概要说明所反映现象数量特征的性质和内容；</span><br><span class="line">业务定义，用于描述管理分析类数据标准的原理性解释；</span><br><span class="line">计算规则，用于描述生成加工规则；</span><br><span class="line">统计口径，用于描述统计指标的时间界限和空间范围；</span><br><span class="line">计量单位，用于表示与其相比较的同种量的大小的约定定义和采用的特定量。如用于计量金额的单位“元”、“美元”等；</span><br><span class="line">指标数值，用于描述经过计算规则加工后得到的具体数值；</span><br><span class="line">指标类型，数量指标/质量指标，外部监管指标、信息披露指标及内部管理指标；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="0x22-数据时效性：数据模型或者数据应用是否能够在预定的时间产出"><a href="#0x22-数据时效性：数据模型或者数据应用是否能够在预定的时间产出" class="headerlink" title="0x22 数据时效性：数据模型或者数据应用是否能够在预定的时间产出"></a>0x22 数据时效性：数据模型或者数据应用是否能够在预定的时间产出</h5><blockquote><ul><li>数据模型、报表是否能够在预定的时间产出，这与资源是否合理分配，作业优先级合理配置息息相关。</li></ul></blockquote><h4 id="0x3-价值产出的角度"><a href="#0x3-价值产出的角度" class="headerlink" title="0x3 价值产出的角度"></a>0x3 价值产出的角度</h4><h5 id="0x31-业务覆盖度"><a href="#0x31-业务覆盖度" class="headerlink" title="0x31 业务覆盖度"></a>0x31 业务覆盖度</h5><blockquote><ul><li>通俗来讲，就是有多少业务方使用数据仓库，并通过数据仓库资产产生业务价值，将数据资产进行量化后评价。</li><li>另外一个角度是数据业务化，从数据中如何发现价值，反作用于业务</li></ul></blockquote><h5 id="0x32-时间价值"><a href="#0x32-时间价值" class="headerlink" title="0x32 时间价值"></a>0x32 时间价值</h5><blockquote><ul><li>数据仓库的构建是否助于业务获取信息时间缩短，所有的信息都可以从数据仓库直接获取</li></ul></blockquote><p><strong>性能</strong>：帮助我们快速查询所需要的数据，减少数据的I/O吞吐，提高使用数据的效率，如宽表。</p><p><strong>成本</strong>：极大地减少不必要的数据冗余，也能实现计算结果复用，极大地降低存储和计算成本。</p><p><strong>效率</strong>：在业务或系统发生变化时，可以保持稳定或很容易扩展，提高数据稳定性和连续性。</p><p><strong>质量</strong>：良好的数据模型能改善数据统计口径的不一致性，减少数据计算错误的可能性。</p><p><strong>价值</strong>：数据使用方对于数仓数据使用程度以及数据模型、数据报表、数据大盘所带来的业务价值。</p><p>数据模型能够促进业务与技术进行有效沟通，形成对主要业务定义和术语的统一认识，具有跨部门、中性的特征，可以表达和涵盖所有的业务。</p><p>在评价一个数据仓库的好坏，笔者认为没有一个固定的标准，相对还是比较主观的认识，从业务方的角度，数仓能够让开发效率提升，提升业务发现才是评价标准，从数仓开发者而言，性能，成本，效率，质量则是评价的标准。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Q1:如何量化评价一个数据仓库的好坏？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​        在网上看到一篇文章关于如何评价数据仓库的，它是这样说的：数据仓库的失败率并非80%都是失败的，很多项目介于成功失败之间；数据仓库项目实施周期比较长，不容易看到成果；因为很大程度上评价成功的标准常常是在既成事实之后采取制定的，实际上大多数用户事先并不清楚自己的目标，从而对数据仓库项目的评价有失偏颇。事实上很多失败的数据仓库在某种程度上也可以看成成功的（至少可以看作介于失败与成功之间）&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x1 数据仓库" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
      <category term="1x12 综合" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/1x12-%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="学习" scheme="http://deletee.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="大数据" scheme="http://deletee.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>从自动化到智能化，OP&amp;URS 在AIOps探索与实战</title>
    <link href="http://deletee.top/2019/10/26/aiops/"/>
    <id>http://deletee.top/2019/10/26/aiops/</id>
    <published>2019-10-26T07:46:30.000Z</published>
    <updated>2019-11-25T01:46:00.092Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、运维面临问题与挑战"><a href="#一、运维面临问题与挑战" class="headerlink" title="一、运维面临问题与挑战"></a>一、运维面临问题与挑战</h4><p>​        眼下，随着信息化、数字化的深入发展，技术飞速迭代，应用服务也不断升级，企业面临的运维压力也越来越大，传统运维受到了前所未有的挑战。</p><p>​        （1）运维内容：传统的互联网运维的内容仅是关注软硬件、网络、应用系统及基础设备的运维，而当前将面临数十万台主机、容器，复杂的网络环境，以及复杂的部署环境：私有云、公有云、跨IDC混合部署</p><p>​        （2）运维工具：传统的互联网运维尽管也利用了工具实现了部分工作的自动化，但主要依赖人力，工作量较大，并效率低下，业务快速增长，技术飞速迭代，意味着工具也要顺势升级。</p><p>​        （3）运维模式：7*24小时服务模式，PE\SA\DBA 成为了“救火式”英雄，成千上万的监控指标，一旦故障出现，SA、PE、DBA、开发童鞋齐上阵，被故障牵着走，被动性强且风险高。</p><p>​    <img src="/knowledge/image-20191027162216325.png" alt="image-20191027162216325" style="zoom:50%;"></p><p>​        OP&amp;URS作为网易运维服务团队，面对新的挑战，这就要求我们打造信息化、数字化的综合管理体系，为企业带来全方位IT运维服务的同时，又可提供定制化、专业化、全链路、无死角的运维解决方案。在大数据时代下，借助机器学习、数据仓库、大数据平台等大数据技术手段，将运维产生的数据进行分析、处理，得出最佳运维策略，以期实现对故障的事先干预，将风险降低到最低，从而降低运维成本，提升运维效率，最终实现运维智能化。</p><a id="more"></a><h4 id="二、AIOps-现状、定位以及我们的理解"><a href="#二、AIOps-现状、定位以及我们的理解" class="headerlink" title="二、AIOps 现状、定位以及我们的理解"></a>二、AIOps 现状、定位以及我们的理解</h4><p>​        AIOps即智能运维，是 Gartner 在2016年提出的概念，真正火起来是在这两年，这个概念提出后，各大厂都已经先后利用AIOps理念培养智能运维人才梯队，建设智能运维平台、打造智能运维体系。腾讯在2018年推出织云平台（Metis已开源）、百度Noah智能运维平台面向商用，Gartner预测到2020年，将近50%的企业将会在他们的业务和 IT 运维方面采用 AIOps 。高效运维发起人萧田国在《AIOps实施之路》中指出了AIOps在效率提升、质量保障、成本优化提出了系列可应用方向以及实施AIOps需要具备的能力。</p><p><img src="/knowledge/image-20191027160601941.png" alt="image-20191027160601941" style="zoom:50%;"></p><p><img src="/knowledge/image-20191025111136655.png" alt="image-20191025111136655"></p><p>​        OP&amp;URS 于2018年加入智能运维大营，拥抱变化，以实现全链路、无死角智能运维体系为目标，旨在利用AI的能力解决运维行业的问题（1）解决重复造轮子的问题（2）解决运维效率仍然低下的问题（3）运维的数据没有得到合理应用的问题。</p><p>​            <img src="/knowledge/image-20191025110041310.png" alt="image-20191025110041310"></p><p>​        此图为故障管理全场景图，该图从服务部署、故障发生、故障发现、故障止损、根因诊断、故障恢复、故障关闭，完整的阐述应用监控的故障管理生命周期。</p><p>​        <strong>OP&amp;URS 实施中的智能运维产品形态</strong></p><p><img src="/knowledge/image-20191025110501460.png" alt="image-20191025110501460"></p><p>​        故障预警：通过算法计算KPI曲线变化趋势，故障前发出故障预警；<br>​        故障告警：能对周期性变化指标进行预测和异常检测，且有告警分级；<br>​        告警合并：支持按照合适的维度对告警进行合并，展现概况信息；<br>​        根因分析：智能对故障根因进行分析，给出最可能的原因，辅助人做决策；<br>​        故障自愈：可以根据故障原因选择合适的故障自愈策略并执行，自动解决故障。</p><p>​        <strong>OP&amp;URS 运维产品生态</strong></p><h4 id="三、OP-amp-URS-在AIOps中实战场景-智能监控"><a href="#三、OP-amp-URS-在AIOps中实战场景-智能监控" class="headerlink" title="三、OP&amp;URS 在AIOps中实战场景-智能监控"></a>三、OP&amp;URS 在AIOps中实战场景-智能监控</h4><p>​        笔者自接触智能运维以来，也是三千烦劳丝，如何让运维“智能”起来？如何让AIOps结合网易现有运维体系实施落地? 又如何推进AIOps发展? 种种挑战考验着我们的团队。经过1年来不断探索、研究、试错，我们首先在监控方面突破，下面介绍如何从0到1建设AIOps应用-智能监控系统心路历程。</p><p><img src="/knowledge/image-20191025214253645.png" alt="image-20191025214253645"></p><h5 id="3-1-运维监控现状"><a href="#3-1-运维监控现状" class="headerlink" title="3.1 运维监控现状"></a>3.1 运维监控现状</h5><p>​        随着互联网，特别是移动互联网的高速发展，web服务已经深入到社会的各个领域，人们使用互联网搜索，购物，付款，娱乐等等。因此，保障web服务的稳定已经变的越来越重要。运维人员通过监控各种各样的关键性能指标（KPI）来判断服务、系统是否稳定，因为KPI如果发生异常，往往意味着与其相关的应用发生了问题。这些KPI可能包括：基础KPI及服务KPI，服务KPI是指能够反映Web服务的规模、质量的性能指标，例如，网页响应时间，网页访问量，连接错误数量等。基础KPI是指能够反映机器（服务器、路由器、交换机）健康状态的性能指标，例如，磁盘使用率，CPU使用率，内存使用率，磁盘IO，网卡吞吐率等。</p><p>​        这些KPI数据表现为时序序列，即一条指标曲线（后文统一称KPI曲线）。由此问题转化为对曲线的异常判断，KPI曲线可以简单分类下面三种类型：</p><p>​        周期型：</p><p><img src="/knowledge/image-20191025143935232.png" alt="image-20191025143935232"></p><p>​        随机型：</p><p>​        <img src="/knowledge/image-20191025143952950.png" alt="image-20191025143952950"></p><pre><code>   平稳型：</code></pre><p><img src="/knowledge/image-20191027102314080.png" alt="image-20191027102314080"></p><p>​        在OP&amp;URS基于基础设施管理的CMDB系统：哨兵系统，通过哨兵 Agent将数据实时/采样的传输至哨兵服务端进行可视化及报警监控。监控系统主要采用规则判定的报警方式，设定上限、下限阈值，触发规则则发出报警，随着业务集成越来越多，体量也越来越大，规则报警也到了其瓶颈，主要有以下痛点：</p><p>​        （1）需要频繁调整阈值</p><p>​                case1:随着业务变化，已有的阈值适用性变差，当业务发生变动时，报警规则也需要及时调整</p><pre><code>            case2:夜间与白天范围不一样，工作日与周末不一样，统一的阈值适用性较差</code></pre><p>​        （2）覆盖范围有限</p><p>​                传统的方式，需要针对指标的每一项进行设定报警规则，比如在DubboProviderCollector，每个方法对应的调用集群的量不一，需要独立配置报警规则，那么配置将会相当耗时且繁琐，并且很多Dubbo服务接口都是随业务随时新增或下线，很容易被忽视。</p><p>​        （3）无效报警过多</p><p>​                阈值规则报警的方式，往往会出现这样的情况，当阈值设定的太高，异常很难被发现，当阈值设定的太低，则会造成大量报警，造成报警风暴，真正有用的报警消息淹没在风暴中。</p><h5 id="3-2-算法引入"><a href="#3-2-算法引入" class="headerlink" title="3.2 算法引入"></a>3.2 算法引入</h5><p><strong>通用异常检测流程：</strong></p><p>​        <img src="/knowledge/image-20191025165642930.png" alt="image-20191025165642930"></p><p>​        针对上述痛点，我们思考如何利用算法来突破传统的阈值报警局限性。于是调研了业界使用的各种异常检测算法，较为常见的算法包括逻辑回归、关联关系挖掘、聚类、决策树、随机森林、支持向量机、蒙特卡洛树搜索、隐式马尔科夫、多示例学习、迁移学习、卷积神经网络等 ,数学算法类：k-sigma，Grubbs，Turkey，MeanPercent，Value，AR，MR，ARIMA。    </p><p>​        曾想使用一种或一类算法来解决所有KPI曲线的预测，而碰到业务情况远比我们想象要复杂，例如：首先面临各种不同曲线表现特征不一，同一类型的算法很难做到召回率整体提升；其二，在同样类型dubbo调用异常 KPI曲线波动情况，在URS是可以接受的，但是在其他产品可能是不能接受的异常，可能在URS在意的指标，在其他产品无需在意；第三，尽管想做到一个模型泛华兼容所有场景，但是所需特征工程工作量巨大，特征也很多。</p><p>​        有人说采用投票的方法，用一大堆算法同时预测，对于结果进行投票，少数服从多数，对于这种方式也是存在一定的缺陷，本身每个算法适用性不一样，那么势必在影响投票结果。在OP&amp;URS采用的是分类算法，即在不同的场景下采用一类算法进行预测，以减少误判率，下面调研和使用了上述部分算法：</p><p>​        机器学习类：</p><div class="table-container"><table><thead><tr><th>算法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>rnn</td><td>适合序列变化</td><td>存在梯度消失现象</td></tr><tr><td>lstm</td><td>解决RNN梯度消息问题</td><td>单指标、单模型</td></tr><tr><td>dnn</td><td>单模型覆盖所有场景，泛华能力比rf更优</td><td>特征工程复杂，需要大量标注数据</td></tr><tr><td>xgboost</td><td>考虑训练数据为稀疏值，分布式并行</td><td>特征工程复杂，需要大量标注数据</td></tr><tr><td>rf</td><td>支持高维度，不用做特征选择、模型泛化能力强</td><td>某些噪音较大的分类或回归问题上会过拟合</td></tr></tbody></table></div><p>​        特征工程是机器学习中一块重要的环节，针对单一KPI表现的数据形态将逐一转换为数据特征，如下将数据特征归类如下5个方面</p><p>​        1、统计特征 ：描述样本内相关的数学表现，例如：方差、均值、中位数、斜率、偏度、峰度等重要指标</p><p>​        2、拟合特征 ：获取曲线的动态特征，根据曲线平稳或不平稳，采用不同模型获取预测值与实际值的差</p><p>​        3、周期特征：利用滑动窗口，傅里叶转换，获取曲线中可能存在的季节性、周期性特征</p><p>​        4、分类特征：基于曲线变换、小波变换、主成分分析等方式 获取曲线分类特征</p><p>​        5、业务特征：KPI具有业务集群效应，工作日邮箱访问量，周末游戏访问量等业务特征</p><p>​        PS：由于篇幅有限，这里就不枚举所有特征，有兴趣的同学可以私下沟通交流。</p><p>​        数学算法类：</p><p>​        （1）恒定阈值类算法<br>​                恒定阈值的含义是表示均值基本恒定，标准差与均值比约等于0（即KPI曲线近似一条直线）</p><p><img src="/knowledge/image-20191025144015477.png" alt="image-20191025144015477"></p><p>​        （2）突升突降类算法</p><p>​                突变的含义是发生了均值漂移</p><p>​                空间转换:𝑟(𝑡)= </p><p><img src="/knowledge/image-20191027174334902.png" alt="image-20191027174334902"></p><p><img src="/knowledge/image-20191027174249030.png" alt="image-20191027174249030"></p><p>​        （3）同比算法<br>​                适用于周期性数据表现，每天同时刻的数据分布相似<br>​                参数估计:求正态分布的均值、方差<br><img src="/knowledge/image-20191027174137205.png" alt="image-20191027174137205">        <img src="/knowledge/image-20191027174204005.png" alt="image-20191027174204005">                        </p><h5 id="3-3-功能设计"><a href="#3-3-功能设计" class="headerlink" title="3.3 功能设计"></a>3.3 功能设计</h5><p><strong>（1）KPI 管理</strong><br>        标注打标：提供标注打标的功能，标记/取消标记为正负样本，标记后样本自动转存样本库<br>        样本管理：提供样本管理功能，检索、图示、编辑、删除等功能<br>        异常查询：经API检测后的时间序列（仅异常）入库存储，提供管理功能，分页查询、检索、放缩等</p><p><strong>（2）模型管理</strong><br>​        模型管理：提供模型管理功能<br>​        模型训练：支持自定义模型训练<br>       （通过PE或开发标注的异常KPI，正常KPI训练符合自己业务的模型，或使用开放的通用模型）</p><p><strong>（3）KPI异常检测</strong><br>        基于数学统计算法集成<br>        基于机器学习算法集成</p><p><strong>（4）多维度报警聚合</strong><br>        按产品维度合并<br>        按应用维度合并<br>        按集群维度合并<br>        按单机维度合并<br>        按业务类型合并<br>        按报警接收人维度合并</p><p><strong>（5）反馈系统</strong><br>        用户标记、报警关闭</p><h5 id="3-4-架构设计"><a href="#3-4-架构设计" class="headerlink" title="3.4 架构设计"></a>3.4 架构设计</h5><p>​        我们将整个智能监控系统分为7个核心功能模块，每个模块承担异常检测流程中相应功能，整体架构上做到模块之间相互独立，通过数据流信号、RPC进行模块通信。</p><div class="table-container"><table><thead><tr><th>序号</th><th>模块名称</th><th></th></tr></thead><tbody><tr><td>1</td><td>配置管理中心</td><td>配置库、模型库、标注库 相关配置与管理（含UI）</td></tr><tr><td>2</td><td>流式计算中心</td><td>KPI预处理、KPI聚合、KPI分发</td></tr><tr><td>3</td><td>数据存储&amp;读取中心</td><td>用于读写KPI时序数据</td></tr><tr><td>4</td><td>消息中心</td><td>数据→ 消息 用于触发模型计算、插值计算</td></tr><tr><td>5</td><td>算法中心</td><td>异常检测、模型训练</td></tr><tr><td>6</td><td>报警处理中心</td><td>用于解析异常KPI及发送报警内容至哨兵报警中心</td></tr><tr><td>7</td><td>反馈系统</td><td>用于反馈报警是否有效，反馈于模型提升</td></tr></tbody></table></div><p>​        <strong>系统架构如下：</strong></p><p><img src="/knowledge/image-20191025162947408.png" alt="image-20191025162947408"></p><p>​        <strong>数据架构如下</strong>：</p><p><img src="/knowledge/image-20191027164834069.png" alt="image-20191027160601941" style="zoom:60%;"></p><h5 id="3-5-难题"><a href="#3-5-难题" class="headerlink" title="3.5 难题"></a>3.5 难题</h5><p>​        前面介绍了OP&amp;URS 智能监控系统的在智能监控系统中整体功能及架构设计，下面简单聊聊我们碰到一些问题以及解决思路：</p><p>（1）实时计算问题</p><p>​            问题描述：1期采用的是Spark Streaming实时计算框架，通过直连Kafka获取数据源，但是在实际生产中，由于数据源是采样收集（有1分钟采样，有2分钟采样），发现每1分钟会有流量尖刺现象，随着KPI数量增多，尖刺更明显。</p><p>​            分析：经分析，发现Spark Streaming 并非是实时的数据抽取Kafka的数据。然而在Spark Streaming在实时计算中不能支持实时读取数据，而是在窗口结束时一次性抽取，造成了一次抽取大量数据，造成网络波动异常，流量尖刺。</p><p>​            解决方案：由于Spark流式计算本质上是微批处理，尽管使用各种手段（限制抽取数据大小、减少窗口大小），仍然指标不治本，由此尝试找Spark的替代方案，我们调研了Flink，经测试Flink能够完美的解决实时抽取的问题，并在数据延时方面处理有一项不到的效果，显著提高了数据准确度。</p><p>（2）性能问题</p><p>​            问题描述：系统在1期时，为了实时计算历史特征（周期性，同比等），算法计算的输入是360个数据点（当前时间区间的120个点，前一天同区间的120个点，7天前同区间的120个点），历史数据存储在HBase（作为TSDB存在）中，但是随着KPI数量增长（当前已有10万级），三个时间段分布在不同的HBase Key（Key 设计：keyId + DayHour， Column设计：minute）中，意味着每次计算需要查询3次HBase，当KPI到达20万级时，需要查询60万次，由于前期采用的还是Spark Steaming模式计算，QPS超过20w，HBase出现明显延迟。</p><p>​            分析：由于算法所需数据点甚大，实时计算抽取历史数据成为瓶颈，团队的攻城狮们自然想到的是减少算法数据需求，最好是用实时的1个数据点进行计算，但对于算法来说是完全不可能实现的，其一，一个点的输入完全构建不了任何特征，算法无从获知曲线形态，不知道同环比等，只会退化到传统的阈值计算；其二，1期所有特征工程基于360个计算，计算点过度减少相当于1期的算法工作全部推翻重做。经过大量讨论论证，得出如下解决方案：</p><p>​            解决方案：</p><p>​        （1）算法输入精简，由360个数据点更改为当前时间区间的60个点，部分实时特征转为离线计算特征，通过内存加载，无需实时进行计算，既保留当前曲线的数据特征，又能减少实时计算模块的需求。</p><p>​        （2）去HBase改为Redis，将60个缓存至Redis中，采用pipeline方法，进行头尾操作（新数据点插入头部，旧的数据点从尾部剔除）</p><p>​            <strong>AIOps前行的路上荆棘丛生，类似的难题还有很多，很多方法也不一定是最优方案，好在大家愿意尝试，愿意推翻重来。</strong></p><h4 id="四、总结与展望"><a href="#四、总结与展望" class="headerlink" title="四、总结与展望"></a>四、总结与展望</h4><p>​        OP&amp;URS 智能监控系统经历了2期的开发，当前智能监控系统2.0已上线，算法召回率在70%左右，报警覆盖度100%，报警配置成本节省90%，当前传媒、考拉、URS、云阅读、网易金融等产品先后接入智能监控报警（排名不分先后），也多次及时的探测到异常事故及时止损，为客户减少损失。</p><p>​        当前系统也存在很多不足：</p><p>​        （1）算法召回率不高，仍需要专家经验与算法的结合</p><p>​        （2）当前智能监控系统只能基于单KPI计算，不满足多KPI计算</p><p>​        （3）依赖数据源的丰富，缺乏全链路监控</p><p>​        智能监控是AIOps中冰山一角，除了解决当前不足以外，我们还有很多工作要做，例如根因分析，场景监控，故障诊断、故障自愈等等，AIOps之路任重而道远，期待广大志同道合的operator加入AIOps阵营，一起努力。</p><p>​        </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、运维面临问题与挑战&quot;&gt;&lt;a href=&quot;#一、运维面临问题与挑战&quot; class=&quot;headerlink&quot; title=&quot;一、运维面临问题与挑战&quot;&gt;&lt;/a&gt;一、运维面临问题与挑战&lt;/h4&gt;&lt;p&gt;​        眼下，随着信息化、数字化的深入发展，技术飞速迭代，应用服务也不断升级，企业面临的运维压力也越来越大，传统运维受到了前所未有的挑战。&lt;/p&gt;
&lt;p&gt;​        （1）运维内容：传统的互联网运维的内容仅是关注软硬件、网络、应用系统及基础设备的运维，而当前将面临数十万台主机、容器，复杂的网络环境，以及复杂的部署环境：私有云、公有云、跨IDC混合部署&lt;/p&gt;
&lt;p&gt;​        （2）运维工具：传统的互联网运维尽管也利用了工具实现了部分工作的自动化，但主要依赖人力，工作量较大，并效率低下，业务快速增长，技术飞速迭代，意味着工具也要顺势升级。&lt;/p&gt;
&lt;p&gt;​        （3）运维模式：7*24小时服务模式，PE\SA\DBA 成为了“救火式”英雄，成千上万的监控指标，一旦故障出现，SA、PE、DBA、开发童鞋齐上阵，被故障牵着走，被动性强且风险高。&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;/knowledge/image-20191027162216325.png&quot; alt=&quot;image-20191027162216325&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;​        OP&amp;amp;URS作为网易运维服务团队，面对新的挑战，这就要求我们打造信息化、数字化的综合管理体系，为企业带来全方位IT运维服务的同时，又可提供定制化、专业化、全链路、无死角的运维解决方案。在大数据时代下，借助机器学习、数据仓库、大数据平台等大数据技术手段，将运维产生的数据进行分析、处理，得出最佳运维策略，以期实现对故障的事先干预，将风险降低到最低，从而降低运维成本，提升运维效率，最终实现运维智能化。&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x3 机器学习" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x3-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="1x30 智能运维" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x3-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/1x30-%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="aiops" scheme="http://deletee.top/tags/aiops/"/>
    
      <category term="机器学习" scheme="http://deletee.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="智能运维" scheme="http://deletee.top/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记02-&gt;Flink配置文件详解</title>
    <link href="http://deletee.top/2019/08/11/flink-learning-notes-02/"/>
    <id>http://deletee.top/2019/08/11/flink-learning-notes-02/</id>
    <published>2019-08-11T02:55:30.000Z</published>
    <updated>2019-08-28T09:18:32.114Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前文已经简要的介绍了flink的如何在Mac下运行一个Maven程序，本文主要聊下在Flink conf目录下的各配置的文件以及文件中各种配置的含义，更多更详细的配置信息请点击：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.1/setup/config.html" target="_blank" rel="noopener">传送门</a> ，下面进入正题…</p><p><img src="/knowledge/flink-config.jpg" alt=""></p><a id="more"></a><h4 id="0x1-配置目录"><a href="#0x1-配置目录" class="headerlink" title="0x1 配置目录"></a>0x1 配置目录</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文中已经定义了<code>FLINK_HOME=/usr/local/Cellar/apache-flink/1.6.0/</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">λ deletee [~] → cd $FLINK_HOME/libexec/conf</span><br><span class="line">λ deletee [1.6.0/libexec/conf] ls -lh</span><br><span class="line">total 112</span><br><span class="line">-rw-r--r--  1 deletee  admin   9.6K Aug  6  2018 flink-conf.yaml</span><br><span class="line">-rw-r--r--  1 deletee  admin   2.1K Aug  6  2018 log4j-cli.properties</span><br><span class="line">-rw-r--r--  1 deletee  admin   1.8K Aug  6  2018 log4j-console.properties</span><br><span class="line">-rw-r--r--  1 deletee  admin   1.7K Aug  6  2018 log4j-yarn-session.properties</span><br><span class="line">-rw-r--r--  1 deletee  admin   1.9K Aug  6  2018 log4j.properties</span><br><span class="line">-rw-r--r--  1 deletee  admin   2.2K Aug  6  2018 logback-console.xml</span><br><span class="line">-rw-r--r--  1 deletee  admin   1.5K Aug  6  2018 logback-yarn.xml</span><br><span class="line">-rw-r--r--  1 deletee  admin   2.3K Aug  6  2018 logback.xml</span><br><span class="line">-rw-r--r--  1 deletee  admin    15B Aug  6  2018 masters</span><br><span class="line">-rw-r--r--  1 deletee  admin    10B Aug  6  2018 slaves</span><br><span class="line">-rw-r--r--  1 deletee  admin   3.2K Aug  6  2018 sql-client-defaults.yaml</span><br><span class="line">-rw-r--r--  1 deletee  admin   1.4K Aug  6  2018 zoo.cfg</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置目录中有flink-conf.yaml（flink的核心配置文件），log4j*.properties 系列log4j文件以及logback*.xml系列日志配置文件，masters、slave用于flink分布式配置，sql-client-defaults.yaml 是Flink SQL 客户端配置，zoo.cfg 是 flink所依赖的 zookeeper的配置文件</p><h4 id="0x2-flink-conf-yaml"><a href="#0x2-flink-conf-yaml" class="headerlink" title="0x2 flink-conf.yaml"></a>0x2 flink-conf.yaml</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flink-conf文件格式为yaml即flink的配置需要遵循yaml的文件格式，下面主要从基础配合，内存管理，内存与性能debug等进行展开。</p><p><strong>— 基础配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">env.java.home:</span> </span><br><span class="line"><span class="comment"># java安装路径，如果没有指定则默认使用系统的$JAVA_HOME环境变量。建议设置此值，因为之前我曾经在standalone模式中启动flink集群，报找不到JAVA_HOME的错误。config.sh中（Please specify JAVA_HOME. Either in Flink config ./conf/flink-conf.yaml or as system-wide JAVA_HOME.）</span></span><br><span class="line"><span class="string">env.java.opts:</span> </span><br><span class="line"><span class="comment"># 定制JVM选项，在Flink启动脚本中执行。需要单独执行JobManager和TaskManager的选项。</span></span><br><span class="line"><span class="string">env.java.opts.jobmanager:</span> </span><br><span class="line"><span class="comment"># 执行jobManager的JVM选项。在Yarn Client环境下此参数无效。</span></span><br><span class="line"><span class="string">env.java.opts.taskmanager:</span></span><br><span class="line"><span class="comment"># 执行taskManager的JVM选项。在Yarn Client环境下此参数无效。</span></span><br><span class="line"><span class="string">jobmanager.rpc.address:</span></span><br><span class="line"><span class="comment"># Jobmanager的IP地址，即master地址。默认是localhost，此参数在HA环境下或者Yarn下无效，仅在local和无HA的standalone集群中有效。</span></span><br><span class="line"><span class="string">jobmanager.rpc.port:</span> </span><br><span class="line"><span class="comment"># JobMamanger的端口，默认是6123。</span></span><br><span class="line"><span class="string">jobmanager.heap.mb:</span> </span><br><span class="line"><span class="comment"># JobManager的堆大小（单位是MB）。当长时间运行operator非常多的程序时，需要增加此值。具体设置多少只能通过测试不断调整。</span></span><br><span class="line"><span class="string">taskmanager.heap.mb:</span></span><br><span class="line"><span class="comment"># 每一个TaskManager的堆大小（单位是MB），由于每个taskmanager要运行operator的各种函数（Map、Reduce、CoGroup等，包含sorting、hashing、caching），因此这个值应该尽可能的大。如果集群仅仅跑Flink的程序，建议此值等于机器的内存大小减去1、2G，剩余的1、2GB用于操作系统。如果是Yarn模式，这个值通过指定tm参数来分配给container，同样要减去操作系统可以容忍的大小（1、2GB）。</span></span><br><span class="line"><span class="string">taskmanager.numberOfTaskSlots:</span></span><br><span class="line"><span class="comment"># 每个TaskManager的并行度。一个slot对应一个core，默认值是1.一个并行度对应一个线程。总的内存大小要且分给不同的线程使用。</span></span><br><span class="line"><span class="string">parallelism.default:</span></span><br><span class="line"><span class="comment"># 每个operator的默认并行度。默认是1.如果程序中对operator设置了setParallelism，或者提交程序时指定了-p参数，则会覆盖此参数。如果只有一个Job运行时，此值可以设置为taskManager的数量 * 每个taskManager的slots数量。即NumTaskManagers  * NumSlotsPerTaskManager 。</span></span><br><span class="line"><span class="string">fs.default-scheme:</span></span><br><span class="line"><span class="comment"># 设置默认的文件系统模式。默认值是file:///即本地文件系统根目录。如果指定了hdfs://localhost:9000/，则程序中指定的文件/user/USERNAME/in.txt，即指向了hdfs://localhost:9000/user/USERNAME/in.txt。这个值仅仅当没有其他schema被指定时生效。一般hadoop中core-site.xml中都会配置fs.default.name。</span></span><br><span class="line"><span class="string">fs.hdfs.hadoopconf:</span></span><br><span class="line"><span class="comment"># HDFS的配置路径。例如：/home/flink/hadoop/hadoop-2.6.0/etc/hadoop。如果配置了这个值，用户程序中就可以简写hdfs路径如：hdfs:///path/to/files。而不用写成：hdfs://address:port/path/to/files这种格式。配置此参数后，Flink就可以找到此路径下的core-site.xml和hdfs-site.xml了。建议配置此参数。</span></span><br></pre></td></tr></table></figure><p><strong>— 内存管理</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于批处理程序，Flink使用了自我的内存管理，默认使用70%的taskmanager.heap.mb的内存。这样Flink批处理程序不会出现OOM问题，因为Flink自己知道有多少内存可以使用，当内存不够时，就使用磁盘空间。而且这样有些operation可以直接访问数据，<br>而不需要序列化数据到java对象。Flink自我管理的内存可以加速程序的执行。如果需要的话，自我管理的内存也可以在JVM堆外被分配，这也有助于提升性能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">taskmanager.memory.size:</span></span><br><span class="line"><span class="comment"># 相对于jobmanager.heap.mb，使用多少内存用于内存管理器进行内存的自我管理。如果没有指定，则默认值是-1，代表参考参数taskmanager.memory.fraction。设置了自我内存管理，Flink在批处理中就可以在堆内或堆外进行排序、hash、cache等操作。</span></span><br><span class="line"><span class="string">taskmanager.memory.fraction:</span></span><br><span class="line"><span class="comment"># 当taskmanager.memory.size没有设置时（或-1），此参数才生效。意思是使用taskmanager.heap.mb的百分比用于自我内存管理。默认值是0.7，代表使用70%的taskmanager的内存。剩余的30%用于UDF的堆以及用于taskmanager间通信数据的内存。</span></span><br><span class="line"><span class="string">taskmanager.memory.off-heap:</span></span><br><span class="line"><span class="comment"># 默认是false。如果设置为true，则taskmanager在JVM堆外分配内存。这对于大段内存的使用很有效。</span></span><br><span class="line"><span class="string">taskmanager.memory.segment-size:</span></span><br><span class="line"><span class="comment"># 内存段的大小，默认单位是32KB。</span></span><br><span class="line"><span class="string">taskmanager.memory.preallocate:</span></span><br><span class="line"><span class="comment"># 默认是false。指定Flink当启动时，是否一次性分配所有管理的内存。</span></span><br><span class="line"><span class="string">如果taskmanager.memory.off-heap设置true，则建议此值也设置为true。</span></span><br></pre></td></tr></table></figure><p><strong>— Kerberos</strong>（Flink安全配置）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flink支持Hadoop生态的kerberos认证服务，例如HDFS，Yarn，或者是HBase，值得注意的是，Flink仅支持Hadoop2.6.1及以上版本，其他的版本可能在Flink作业中失败。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指示是否从 Kerberos ticket 缓存中读取</span></span><br><span class="line"><span class="string">security.kerberos.login.use-ticket-cache:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 包含用户凭据的 Kerberos 密钥表文件的绝对路径</span></span><br><span class="line"><span class="string">security.kerberos.login.keytab:</span> <span class="string">/path/to/kerberos/keytab</span></span><br><span class="line"><span class="comment"># 与 keytab 关联的 Kerberos 主体名称</span></span><br><span class="line"><span class="string">security.kerberos.login.principal:</span> <span class="string">flink-user</span></span><br><span class="line"><span class="comment"># 以逗号分隔的登录上下文列表，用于提供 Kerberos 凭据（例如，`Client，KafkaClient`使用凭证进行 ZooKeeper 身份验证和 Kafka 身份验证）</span></span><br><span class="line"><span class="string">security.kerberos.login.contexts:</span> <span class="string">Client,KafkaClient</span></span><br></pre></td></tr></table></figure><p><strong>—Zookeeper安全配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 覆盖以下配置以提供自定义 ZK 服务名称</span></span><br><span class="line"><span class="string">zookeeper.sasl.service-name:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="comment"># 该配置必须匹配 "security.kerberos.login.contexts" 中的列表（含有一个）</span></span><br><span class="line"><span class="string">zookeeper.sasl.login-context-name:</span> <span class="string">Client</span></span><br></pre></td></tr></table></figure><p><strong>—HistoryServer</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你可以通过 bin/historyserver.sh (start|stop) 命令启动和关闭 HistoryServer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将已完成的作业上传到的目录</span></span><br><span class="line"><span class="string">jobmanager.archive.fs.dir:</span> <span class="attr">hdfs:///completed-jobs/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于 Web 的 HistoryServer 的地址</span></span><br><span class="line"><span class="string">historyserver.web.address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 基于 Web 的 HistoryServer 的端口号</span></span><br><span class="line"><span class="string">historyserver.web.port:</span> <span class="number">8082</span></span><br><span class="line"><span class="comment"># 以逗号分隔的目录列表，用于监视已完成的作业</span></span><br><span class="line"><span class="string">historyserver.archive.fs.dir:</span> <span class="attr">hdfs:///completed-jobs/</span></span><br><span class="line"><span class="comment"># 刷新受监控目录的时间间隔（以毫秒为单位）</span></span><br><span class="line"><span class="string">historyserver.archive.fs.refresh-interval:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p><strong>—其他</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">askmanager.tmp.dirs:</span>  </span><br><span class="line"><span class="comment"># taskmanager的临时目录，默认是系统的tmp路径。可以指定多个路径，通过：隔开，多路径的设置导致多个线程去执行IO操作。</span></span><br><span class="line"><span class="string">taskmanager.log.path:</span></span><br><span class="line"><span class="comment"># taskmanager的日志文件路径，默认在$FLINK_HOME/log </span></span><br><span class="line"><span class="string">jobmanager.web.address:</span>  </span><br><span class="line"><span class="comment"># Jobmanager的web接口地址，默认是anyLocalAddress()，即所有地址的请求都会被处理，指向jobmanager的IP地址</span></span><br><span class="line"><span class="string">jobmanager.web.port:</span>  </span><br><span class="line"><span class="comment"># Jobmanager的web接口，默认是8081</span></span><br><span class="line"><span class="string">jobmanager.web.tmpdir:</span>  </span><br><span class="line"><span class="comment"># 存放web接口静态文件的路径，上传的jar文件也会存储在此路径（这里指通过webUI启动job时上传的jar文件）。默认是系统tmp路径。</span></span><br><span class="line"><span class="string">jobmanager.web.upload.dir:</span>  </span><br><span class="line"><span class="comment"># 通过web UI上传的jar文件的路径，如果没有指定，则指向jobmanager.web.tmpdir的路径。</span></span><br><span class="line"><span class="string">fs.overwrite-files:</span>  </span><br><span class="line"><span class="comment"># 当输出文件到文件系统时，是否覆盖已经存在的文件。默认是false</span></span><br><span class="line"><span class="string">fs.output.always-create-directory:</span>  </span><br><span class="line"><span class="comment"># 文件输出时是否单独创建一个子目录。默认是false，即直接将文件输出到指向的目录下</span></span><br><span class="line"><span class="string">taskmanager.network.numberOfBuffers:</span> </span><br><span class="line"><span class="comment"># taskmanager数据在网络传输的大小，默认是2048个块，每个块大小是32KB。这个值官方建议的值为：#slots-per-TM^2 * #TMs * 4。我之前按照这个建议配置时，系统出错说这个值太小。个人建议这个值可以稍微设置大些。</span></span><br><span class="line"><span class="string">state.backend:</span> </span><br><span class="line"><span class="comment"># 当检查点被激活时，保存的有状态的检查点的目录。默认是存在jobmanager的内存中。也支持保存到hdfs或者rocksdb中。默认是jobmanager，如果是hdfs，则制定filesystem。例如hdfs://namenode-host:port/flink-checkpoints；如果是RocksDB，则制定RocksDB的路径。</span></span><br><span class="line"><span class="string">state.backend.fs.checkpointdir:</span>  </span><br><span class="line"><span class="comment"># 存储检查点的具体路径，必须是Flink可访问的路径。例如：hdfs://namenode-host:port/flink-checkpoints。</span></span><br><span class="line"><span class="string">state.backend.rocksdb.checkpointdir:</span>  </span><br><span class="line"><span class="comment"># 存储RocksDB的检查点路径，默认是taskmanager.tmp.dirs</span></span><br><span class="line"><span class="string">state.checkpoints.dir:</span>  </span><br><span class="line"><span class="comment"># checkpoint数据的目录。</span></span><br><span class="line"><span class="string">recovery.zookeeper.storageDir:</span>  </span><br><span class="line"><span class="comment"># 定义Jobmanager的的元数据信息，zookeeper只是保存一个指向此目录的指针，在HA环境下用于Jobmanager的恢复。例如设置为: hdfs:///flink/recovery。</span></span><br><span class="line"><span class="string">blob.storage.directory:</span>  </span><br><span class="line"><span class="comment"># 指定taskmanager中Blob文件（jar）的路径。</span></span><br><span class="line"><span class="string">blob.server.port:</span>  </span><br><span class="line"><span class="comment"># taskmanager中blob服务器的端口号，默认是0，即操作系统选定一个可用的端口。可以指定一个范围 (“50100-50200”)，避免相同机器中运行多个Jobmanager的情况时使用。</span></span><br><span class="line"><span class="attr">restart-strategy:</span> </span><br><span class="line"><span class="comment"># 默认是"none"，即不设置任何重启策略。如果设置为"fixed-delay"，则代表固定延迟策略；如果指定"failure-rate"，则代表失败的时间比例。</span></span><br><span class="line"><span class="string">restart-strategy.fixed-delay.attempts:</span>  </span><br><span class="line"><span class="comment"># fixed-delay模式下的恢复尝试次数，默认是1次。</span></span><br><span class="line"><span class="string">restart-strategy.fixed-delay.delay:</span>  </span><br><span class="line"><span class="comment"># fixed-delay模式下，两次重启尝试之间的延迟时间。默认为akka.ask.timeout.</span></span><br><span class="line"><span class="string">restart-strategy.failure-rate.max-failures-per-interval:</span> </span><br><span class="line"><span class="comment"># failure-rate模式下，失败重启的最大次数，默认是1次。</span></span><br><span class="line"><span class="string">restart-strategy.failure-rate.failure-rate-interval:</span> </span><br><span class="line"><span class="comment"># failure-rate下，失败时间间隔的度量。</span></span><br><span class="line"><span class="string">restart-strategy.failure-rate.delay:</span> </span><br><span class="line"><span class="comment"># failure-rate模式下，两次重启之间的延迟时间，默认是akka.ask.timeout.</span></span><br></pre></td></tr></table></figure><p><img src="/knowledge/20161219111605306.png" alt="20161219111605306"></p><h3 id="0x3-slaves-master"><a href="#0x3-slaves-master" class="headerlink" title="0x3 slaves/master"></a>0x3 slaves/master</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master host:port</span></span><br><span class="line">λ deletee [1.6.0/libexec/conf] cat masters</span><br><span class="line">localhost:8081</span><br><span class="line"></span><br><span class="line"><span class="comment">#slave host</span></span><br><span class="line">λ deletee [1.6.0/libexec/conf] cat slaves </span><br><span class="line">localhost</span><br></pre></td></tr></table></figure><h3 id="0x4-zoo-cfg"><a href="#0x4-zoo-cfg" class="headerlink" title="0x4 zoo.cfg"></a>0x4 zoo.cfg</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个 tick 的毫秒数</span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始同步阶段可以采用的 tick 数</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送请求和获取确认之间可以传递的 tick 数</span></span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储快照的目录</span></span><br><span class="line"><span class="comment"># dataDir=/tmp/zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端将连接的端口</span></span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ZooKeeper quorum peers</span></span><br><span class="line">server<span class="number">.1</span>=localhost:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="comment"># server.2=host:peer-port:leader-port</span></span><br></pre></td></tr></table></figure><h3 id="0x5-日志配置"><a href="#0x5-日志配置" class="headerlink" title="0x5 日志配置"></a>0x5 日志配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flink在不同平台运行的日志文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j-cli.properties</span><br><span class="line">log4j-console.properties</span><br><span class="line">log4j-yarn-session.properties</span><br><span class="line">log4j.properties</span><br><span class="line">logback-console.xml</span><br><span class="line">logback-yarn.xml</span><br><span class="line">logback.xml</span><br></pre></td></tr></table></figure><h3 id="0x6-sql-client-defaults-yaml"><a href="#0x6-sql-client-defaults-yaml" class="headerlink" title="0x6 sql-client-defaults.yaml"></a>0x6 sql-client-defaults.yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">execution:</span></span><br><span class="line">  <span class="comment"># 'batch' or 'streaming' execution</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">streaming</span></span><br><span class="line">  <span class="comment"># allow 'event-time' or only 'processing-time' in sources</span></span><br><span class="line"><span class="attr">  time-characteristic:</span> <span class="string">event-time</span></span><br><span class="line">  <span class="comment"># interval in ms for emitting periodic watermarks</span></span><br><span class="line"><span class="attr">  periodic-watermarks-interval:</span> <span class="number">200</span></span><br><span class="line">  <span class="comment"># 'changelog' or 'table' presentation of results</span></span><br><span class="line"><span class="attr">  result-mode:</span> <span class="string">changelog</span></span><br><span class="line">  <span class="comment"># parallelism of the program</span></span><br><span class="line"><span class="attr">  parallelism:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># maximum parallelism</span></span><br><span class="line"><span class="attr">  max-parallelism:</span> <span class="number">128</span></span><br><span class="line">  <span class="comment"># minimum idle state retention in ms</span></span><br><span class="line"><span class="attr">  min-idle-state-retention:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># maximum idle state retention in ms</span></span><br><span class="line"><span class="attr">  max-idle-state-retention:</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">deployment:</span></span><br><span class="line">  <span class="comment"># general cluster communication timeout in ms</span></span><br><span class="line"><span class="attr">  response-timeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment"># (optional) address from cluster to gateway</span></span><br><span class="line"><span class="attr">  gateway-address:</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># (optional) port from cluster to gateway</span></span><br><span class="line"><span class="attr">  gateway-port:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Flink Sql Client 可以了解更多关于 <a href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/table/sqlClient.html" target="_blank" rel="noopener">Flink sql的配置及使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前文已经简要的介绍了flink的如何在Mac下运行一个Maven程序，本文主要聊下在Flink conf目录下的各配置的文件以及文件中各种配置的含义，更多更详细的配置信息请点击：&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.1/setup/config.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt; ，下面进入正题…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/knowledge/flink-config.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x2 技术平台" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="1x23 Flink" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/1x23-Flink/"/>
    
    
      <category term="flink" scheme="http://deletee.top/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink学习笔记01-&gt;Mac下部署flink并构建简单程序</title>
    <link href="http://deletee.top/2019/08/11/flink-learning-notes-01/"/>
    <id>http://deletee.top/2019/08/11/flink-learning-notes-01/</id>
    <published>2019-08-11T02:55:30.000Z</published>
    <updated>2019-08-21T01:18:55.772Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着Flink大数据平台快速发展及日益成熟，公司也逐步利用Flink来解决业务问题，之前也学过Scala，Spark，由于本人在实际工作中应用场景较少，基本上又忘了。本次利用一个月的时间，每天更新一篇自学笔记用以记录及知识分享。</p><p><img src="/knowledge/flink-logo.jpeg" alt=""></p><a id="more"></a><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk-1.8</span><br><span class="line">flink-1.6.0</span><br></pre></td></tr></table></figure><p>Mac 下安装 flink<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install apache-flink</span><br></pre></td></tr></table></figure></p><p>若是网络不好的话，可能会下载非常慢（brew下载未完成的文件后缀为.incomplete）或是失败，可以把brew待下载的包通过其他渠道先下载到cache路径下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deletee [~] → brew --cache</span><br><span class="line">/Users/deletee/Library/Caches/Homebrew</span><br></pre></td></tr></table></figure></p><p>具体操作思路：</p><p><a href="https://archive.apache.org/dist/flink/flink-1.6.0/flink-1.6.0-bin-hadoop27-scala_2.11.tgz" target="_blank" rel="noopener">点击下载 flink安装包</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1：  <span class="comment"># brew install apache-flink</span></span><br><span class="line"></span><br><span class="line">以上命令会提示开始下载一个文件，但进度很慢。半个小时过去了，才到30%。</span><br><span class="line">复制上面的下载链接，使用其它下载工具下载。例如使用迅雷，可以在5分钟左右下载完成，也可以尝试配合vpn下载。加速下载的办法大家都是各有绝招，根据自己的环境选择最快的一种下载方式即可。</span><br><span class="line"></span><br><span class="line">2：找到brew下载文件的目录，将刚才下载的文件移动到目录</span><br><span class="line">    <span class="comment"># cd `brew --cache`</span></span><br><span class="line">     //进入brew的下载目录 </span><br><span class="line">    <span class="comment"># rm apache-flink-1.6.0.tar.gz.incomplete</span></span><br><span class="line">     //删除刚才下载一半的文件</span><br><span class="line">    <span class="comment"># mv apache-flink-1.6.0.tar.gz ./</span></span><br><span class="line">    //将下载好的压缩包放到brew下载目录</span><br><span class="line">3：继续执行：brw install apache-flink</span><br></pre></td></tr></table></figure><p>安装之后，可以通过命令进行验证<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deletee [~] → flink -v</span><br><span class="line">Version: 1.6.0, Commit ID: ff472b4</span><br></pre></td></tr></table></figure></p><p>那么安装好的flink在什么位置呢？<code>/usr/local/Cellar/apache-flink/1.6.0/</code><br>我们配置下FLINK_HOME, <code>vim ~/.bashrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> FLINK_HOME=/usr/<span class="built_in">local</span>/Cellar/apache-flink/1.6.0/</span><br></pre></td></tr></table></figure><h4 id="启动Flink"><a href="#启动Flink" class="headerlink" title="启动Flink"></a>启动Flink</h4><p>一键启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">→ <span class="built_in">cd</span> <span class="variable">$FLINK_HOME</span>/libexec                                                                                                                            [ac229f9]</span><br><span class="line">deletee [apache-flink/1.6.0/libexec]$: bin/start-cluster.sh                                                                                                                              [ac229f9]</span><br><span class="line">Starting cluster.</span><br><span class="line">Starting standalonesession daemon on host localhost.</span><br><span class="line">Starting taskexecutor daemon on host localhost.</span><br></pre></td></tr></table></figure><p>是的，可以通过$FLINK_HOME/libexec 路径下 bin目录下 启动脚本来启动 flink</p><p>此时可以通过浏览器访问: <a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a> 访问flink web界面</p><p><img src="/knowledge/flink-install-check.jpg" alt=""></p><h4 id="构建Flink-Maven-工程-flink-java"><a href="#构建Flink-Maven-工程-flink-java" class="headerlink" title="构建Flink Maven 工程 (flink-java)"></a>构建Flink Maven 工程 (flink-java)</h4><p><strong>简要说明</strong></p><p>​        Demo是接收套接字输入流进行分词计数。</p><p><img src="/knowledge/flink-maven-java-create.jpg" alt=""></p><p>工程信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hz.deletee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-learning<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hz.deletee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-learning<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.11.12<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.build.timestamp.format</span>&gt;</span>yyyyMMddHHmmss<span class="tag">&lt;/<span class="name">maven.build.timestamp.format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Add connector dependencies here. They must be in the default scope (compile). --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Add logging framework, to produce console output when running in the IDE. --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- These dependencies are excluded from the application JAR by default. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hz.detelee.x01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTextStreamWordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//参数检查</span></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"USAGE:\nSocketTextStreamWordCount &lt;hostname&gt; &lt;port&gt;"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String hostname = args[<span class="number">0</span>];</span><br><span class="line">        Integer port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// set up the streaming execution environment</span></span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; stream = env.socketTextStream(hostname, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = stream.flatMap(<span class="keyword">new</span> LineSplitter())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line">        sum.print();</span><br><span class="line">        env.execute(<span class="string">"Java WordCount from SocketTextStream Example"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LineSplitter</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> </span>&#123;</span><br><span class="line">            String[] tokens = s.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String token: tokens) &#123;</span><br><span class="line">                <span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(token, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.skpi.test=true</span><br></pre></td></tr></table></figure><p><strong>执行</strong><br>开启数据入监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启输入流 端口监听</span></span><br><span class="line">nc -kl 9000</span><br></pre></td></tr></table></figure><p>运行程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink run -c org.hz.detelee.x01.SocketTextStreamWordCount flink-learning-1.0-SNAPSHOT.jar 127.0.0.1 9000</span><br></pre></td></tr></table></figure></p><p>查看结果日志<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $FLINK_HOME/libexec/log/</span><br><span class="line">tail -f flink-deletee-taskexecutor-0-localhost.out</span><br></pre></td></tr></table></figure></p><p><img src="/knowledge/flink-run-result.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说在前面的话&quot;&gt;&lt;a href=&quot;#说在前面的话&quot; class=&quot;headerlink&quot; title=&quot;说在前面的话&quot;&gt;&lt;/a&gt;说在前面的话&lt;/h4&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;随着Flink大数据平台快速发展及日益成熟，公司也逐步利用Flink来解决业务问题，之前也学过Scala，Spark，由于本人在实际工作中应用场景较少，基本上又忘了。本次利用一个月的时间，每天更新一篇自学笔记用以记录及知识分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/knowledge/flink-logo.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x2 技术平台" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="1x23 Flink" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/1x23-Flink/"/>
    
    
      <category term="flink" scheme="http://deletee.top/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>Git创建与合并分支</title>
    <link href="http://deletee.top/2019/04/11/git-repository/"/>
    <id>http://deletee.top/2019/04/11/git-repository/</id>
    <published>2019-04-11T07:46:30.000Z</published>
    <updated>2019-04-11T04:53:43.744Z</updated>
    
    <content type="html"><![CDATA[<p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><a id="more"></a><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p><p> 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><video width="100%" controls style="vertical-align: middle; max-width: 100%; height: auto; box-sizing: border-box; color: rgb(58, 58, 58); font-family: STHeitiSC-Light; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"></video><p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907170801199e153159cc4a438bed8d255edf157a000/0" alt="set-utf8-notepad++"></p><p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><video width="100%" controls style="vertical-align: middle; max-width: 100%; height: auto; box-sizing: border-box; color: rgb(58, 58, 58); font-family: STHeitiSC-Light; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"></video><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>现在总结一下今天学的两点内容：</p><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是版本库呢？版本库又名仓库，英文名&lt;strong&gt;repository&lt;/strong&gt;，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x02 Git管理" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x02-Git%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="shell" scheme="http://deletee.top/tags/shell/"/>
    
      <category term="awk" scheme="http://deletee.top/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Git简介</title>
    <link href="http://deletee.top/2019/04/11/git-brief/"/>
    <id>http://deletee.top/2019/04/11/git-brief/</id>
    <published>2019-04-11T07:46:30.000Z</published>
    <updated>2019-04-11T04:49:33.112Z</updated>
    
    <content type="html"><![CDATA[<p>Git是什么？</p><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><p>Git有什么特点？简单来说就是：高端大气上档次！</p><p>那什么是版本控制系统？</p><p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：</p><p>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013848606651673ff1c83932d249118bf8fd5c58c15ca2000/0" alt="lots-of-docs"></p><a id="more"></a><p>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。</p><p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p><p>更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。</p><p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p><p>这个软件用起来就应该像这个样子，能记录每次文件的改动：</p><div class="table-container"><table><thead><tr><th style="text-align:left">版本</th><th style="text-align:left">文件名</th><th style="text-align:left">用户</th><th style="text-align:left">说明</th><th style="text-align:left">日期</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">删除了软件服务条款5</td><td style="text-align:left">7/12 10:38</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">增加了License人数限制</td><td style="text-align:left">7/12 18:09</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">service.doc</td><td style="text-align:left">李四</td><td style="text-align:left">财务部门调整了合同金额</td><td style="text-align:left">7/13 9:51</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">延长了免费升级周期</td><td style="text-align:left">7/14 15:17</td></tr></tbody></table></div><p>这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。</p><h4 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h4><hr><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是什么？&lt;/p&gt;
&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统（没有之一）。&lt;/p&gt;
&lt;p&gt;Git有什么特点？简单来说就是：高端大气上档次！&lt;/p&gt;
&lt;p&gt;那什么是版本控制系统？&lt;/p&gt;
&lt;p&gt;如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：&lt;/p&gt;
&lt;p&gt;想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.liaoxuefeng.com/cdn/files/attachments/0013848606651673ff1c83932d249118bf8fd5c58c15ca2000/0&quot; alt=&quot;lots-of-docs&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x02 Git管理" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x02-Git%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="shell" scheme="http://deletee.top/tags/shell/"/>
    
      <category term="awk" scheme="http://deletee.top/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>[转]职场晋升进阶宝典：都是知识点</title>
    <link href="http://deletee.top/2019/01/26/promotion-reply/"/>
    <id>http://deletee.top/2019/01/26/promotion-reply/</id>
    <published>2019-01-26T15:15:30.000Z</published>
    <updated>2019-11-23T15:05:23.394Z</updated>
    
    <content type="html"><![CDATA[<p>时间眨眼到了5月，阿里人最近都在忙什么呢？橙子去公司内网看了看，发现“晋升”已经成了热搜词。</p><p><strong>晋升，可不是你想象中简单的升职加薪哦。</strong></p><p>它既是认可，也是期望。是对过去一段时间内，个人的能力成长和业务产出的认可；也是对今后的责任、付出提出了更高的要求和期望。听说面对压力，不少同学还是挺紧张的，这种关键时候，贴心的橙子自然会想方设法助大家一臂之力咯~你看，我千方百计找到了几大绝招哦！话说这绝招从哪儿学来的？</p><p>《晋升答辩的7个小技巧》是玉顺（玉顺，飞猪（阿里集团旗下旅行品牌）产品总监，曾就职于美国微软Bing、腾讯。）在2016年写的，同步发表在某社交平台，当时就被评为自媒体热文。今年这个时候恰逢晋升季，他就拿出来跟小伙伴们分享，本文略有删减 。</p><p><img src="/knowledge/ca35-hhtfwqq6752390.jpg" alt="ca35-hhtfwqq6752390"></p> <a id="more"></a><p><strong>01 展示你的核心能力。(Show your core competency, through projects)</strong></p><p>好多同学的答辩PPT都是按照时间排序，把自己做过的大大小小的项目罗列一遍。这样做最大的问题是目的不清楚，答辩本身不是评估项目，而是评估你这个人，评估你这个人的能力。</p><p>我首先要问你的一个问题就是，“你想要展示哪些核心能力？”</p><p>在答辩的准备上，你一定不能沉没到项目的细节里面，要跳出项目，仔细考虑自己的核心能力有哪些提升，如何把自己的核心能力表现出来。</p><p><strong>02 展示你的领导力。(Show leadership in small wins)</strong> </p><p>比如，你如果想在任何一个岗位上有出色的成绩，单靠完成工作是不够的，你需要展现“领导力”：主动承担、积极推动。这能让面试官相信，你可以承担更大更重要的责任。</p><p>有同学认为领导力是需要title才能发挥出来的，不，你不一定是Leader的title，各个通道的同学在平常的工作中，都可以展现领导力。</p><p>比如开发同学并没有等着产品经理来催进度、协调资源，而是主动和产品、前端、iOS、安卓的负责同学沟通，推动项目的进展和问题的解决，目标是在细分领域做到业界第一，这就是领导力。</p><p><strong>03 深入思考。(Think twice on “why”)</strong></p><p>我发现在面试中，有一类同学容易脱颖而出，他们往往在做过的项目中有自己较深入的思考。</p><p>比如同样一个项目，一个技术同学可能只记得写了多少行代码，完成了什么功能；另一个同学可以清晰地分析架构设计、可扩展性、容错，以及不同实现框架的对比，展现出了极强的思考能力。</p><p>这类深入思考的同学，比单纯只是执行的同学，能够承担更复杂和更重要的项目。</p><p>例如，每个产品创新，都需要产品经理站在整个行业生态的角度去考虑和布局，在做具体功能之前想清楚价值链的各个环节和价值洼地，想清楚了之后再来设计具体的场景和功能。</p><p>“Keep your feet on the ground, head above the cloud” ，这是我很喜欢一句话，也是鼓励大家多多思考，站在更高的角度和格局上去思考和提高。</p><p><strong>04 强调数据度量。 (Emphasize more on metrics, less on idea)</strong></p><p>在你的项目中，你如何采集数据、建立度量、分析数据，是表现你科学思考的重要手段。</p><p>有一些同学从心里会有点瞧不起做数据的工作，觉得更喜欢做产品功能开发，但是，数据分析和决策能力是一种非常重要的能力。现代的互联网开发讲究的是Growth hacking，它的核心是持续的数据驱动的产品设计和开发流程。Big data, A/B testing都是越来越普及的工具。</p><p>有时候有的同学找到我，请我做一个两难的决策，我问了几个问题往往就发现，他对数据的分析和采集不够；反过来，很多时候，这些数据出来了，不需要问我就已经可以找到清晰合理的方案了。</p><p>推荐一本书叫做“How To Measure Anything” ，可以帮助建立一套以数据驱动的决策体系，不管你是什么岗位，读一下都是很有好处的。</p><p><strong>05 知行合一。(Walk the talk, talk the walk)</strong></p><p>虽然每年的晋升机会是有限的，但职业能力的提升是一个持续的过程。每天进步一点点，3个月之后就会大不一样。</p><p>这里面的关键是，光知道是不够的，要去做，不断地做，不断地思考。做投资有一个重要的概念是复利，提高自己也是一样的，不断地积累，哪怕每次只有一点点，这个积累的力量是惊人的。</p><p>这里的英文标题我用的是Walk the talk, talk the walk. 它有两层意思，Walk the talk, 是实践你所知道的，talk the walk是讲你实践过的。平时你需要walk the talk,晋升评审的时候talk the walk，一切就变得很容易了。</p><p><strong>06 陈述要简洁。(KISS: Keep it Simple, Stupid)</strong></p><p>我看很多同学讲PPT有一个主要的问题，就是无关的内容太多。回到第一点，罗列内容和项目是没有用的，关键是你是否展示了你的核心能力。</p><p>网络接口设计中有一个重要的原则是KISS: Keep it simple, stupid. 你在讲PPT的时候也需要非常简洁， 只突出你的核心能力，整个PPT都是围绕你的核心能力组织和展开，你讲的每一句话都是围绕这一个目标。</p><p><strong>07 练习，练习，练习。(Practice, practice, practice)</strong></p><p>再好的演讲者也需要不断练习。乔布斯每次苹果发布会都要练习几十次，精益求精。对我们这些平时不太有机会演讲的产品和技术同学们，更加需要加倍的练习。</p><p>Stanford大学的教授Andrew Ng，是个美籍华人，刚加入Stanford的时候，因为不善言谈，讲课排名垫底，后来靠不断的有意识的练习，变成了最受欢迎的老师之一；他的机器学习课程也是Coursera上的最受欢迎的课程之一。我上过他的机器学习，讲解生动有趣，也让我坚定地相信，每一个同学都可以成为一个出色的演讲者，只是需要“练习，练习，练习”。</p><p><strong>在阿里有句老话：成长是自己的事儿。</strong></p><p>如果每一天都在重复着昨天，没有思考、总结和提升，那么你的人生就像荡秋千，只是在重复摇摆而已。</p><p><strong>蹲下来，是为了跳得更高。</strong></p><p>如果对照着“聪明、乐观、皮实、自省”这“四好青年”标准，你样样都达标很优秀了，那么晋升就是一个水到渠成的结果。 </p><p>没有比脚更长的路，没有比人更高的山，为了更好的自己，你我共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间眨眼到了5月，阿里人最近都在忙什么呢？橙子去公司内网看了看，发现“晋升”已经成了热搜词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;晋升，可不是你想象中简单的升职加薪哦。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它既是认可，也是期望。是对过去一段时间内，个人的能力成长和业务产出的认可；也是对今后的责任、付出提出了更高的要求和期望。听说面对压力，不少同学还是挺紧张的，这种关键时候，贴心的橙子自然会想方设法助大家一臂之力咯~你看，我千方百计找到了几大绝招哦！话说这绝招从哪儿学来的？&lt;/p&gt;
&lt;p&gt;《晋升答辩的7个小技巧》是玉顺（玉顺，飞猪（阿里集团旗下旅行品牌）产品总监，曾就职于美国微软Bing、腾讯。）在2016年写的，同步发表在某社交平台，当时就被评为自媒体热文。今年这个时候恰逢晋升季，他就拿出来跟小伙伴们分享，本文略有删减 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/knowledge/ca35-hhtfwqq6752390.jpg&quot; alt=&quot;ca35-hhtfwqq6752390&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="3x 职场篇" scheme="http://deletee.top/categories/3x-%E8%81%8C%E5%9C%BA%E7%AF%87/"/>
    
      <category term="3x1 职场宝典" scheme="http://deletee.top/categories/3x-%E8%81%8C%E5%9C%BA%E7%AF%87/3x1-%E8%81%8C%E5%9C%BA%E5%AE%9D%E5%85%B8/"/>
    
    
      <category term="职场" scheme="http://deletee.top/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>2018年，自己做了什么？</title>
    <link href="http://deletee.top/2019/01/26/2018-summary/"/>
    <id>http://deletee.top/2019/01/26/2018-summary/</id>
    <published>2019-01-26T13:29:30.000Z</published>
    <updated>2019-01-26T15:27:18.964Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回想2018年，大部分日常工作是日志收集、数据统计、数据分析等工作，太过零碎有不能好好的展开，所以还是蛮纠结的。所以打算从可以提炼的日常以及唯一一个值得说道的项目：数据仓库机房迁移作为2018年完成的总结。</p><p><img src="/knowledge/001ouy5Qzy7qoMdlRc1e5.jpeg" alt="001ouy5Qzy7qoMdlRc1e5"></p><a id="more"></a><h4 id="0x1-数据仓库机房迁移"><a href="#0x1-数据仓库机房迁移" class="headerlink" title="0x1 数据仓库机房迁移"></a>0x1 数据仓库机房迁移</h4><h4 id="0x2-数据开发的日常"><a href="#0x2-数据开发的日常" class="headerlink" title="0x2 数据开发的日常"></a>0x2 数据开发的日常</h4><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;回想2018年，大部分日常工作是日志收集、数据统计、数据分析等工作，太过零碎有不能好好的展开，所以还是蛮纠结的。所以打算从可以提炼的日常以及唯一一个值得说道的项目：数据仓库机房迁移作为2018年完成的总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/knowledge/001ouy5Qzy7qoMdlRc1e5.jpeg&quot; alt=&quot;001ouy5Qzy7qoMdlRc1e5&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="3x 职场篇" scheme="http://deletee.top/categories/3x-%E8%81%8C%E5%9C%BA%E7%AF%87/"/>
    
      <category term="3x0 总结与规划" scheme="http://deletee.top/categories/3x-%E8%81%8C%E5%9C%BA%E7%AF%87/3x0-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A7%84%E5%88%92/"/>
    
      <category term="3x00 2018年总结" scheme="http://deletee.top/categories/3x-%E8%81%8C%E5%9C%BA%E7%AF%87/3x0-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A7%84%E5%88%92/3x00-2018%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工作总结" scheme="http://deletee.top/tags/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一起来学Scala(4)-循环</title>
    <link href="http://deletee.top/2019/01/22/scala-programing-loop/"/>
    <id>http://deletee.top/2019/01/22/scala-programing-loop/</id>
    <published>2019-01-22T14:02:17.000Z</published>
    <updated>2019-01-26T13:44:42.628Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;&ensp;今天学习的内容是循环，循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：<br><img src="http://www.runoob.com/wp-content/uploads/2015/12/loop.png" alt="loop.png"><br><a id="more"></a><br>&ensp;&ensp;&ensp;&ensp;&ensp;Scala中的循环与Java中循环表现不一样，主要体现在写法及卫语句支持。下面看一段伪代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(line &lt;- source.getLines)&#123;</span><br><span class="line">    <span class="keyword">for</span> (char &lt;- line)&#123;</span><br><span class="line">        <span class="keyword">if</span> char.isLetter&#123;</span><br><span class="line">            <span class="comment">// your code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala可以这样简写…</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;line &lt;- source.getLines)&#123;</span><br><span class="line">    char &lt;- line</span><br><span class="line">    <span class="keyword">if</span> char.isLetter</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala可使得循环的写法非常简洁。</p><h4 id="0x1-循环类型"><a href="#0x1-循环类型" class="headerlink" title="0x1 循环类型"></a>0x1 循环类型</h4><h5 id="0x10-for循环"><a href="#0x10-for循环" class="headerlink" title="0x10 for循环"></a>0x10 for循环</h5><p><strong>表达式:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x &lt;- <span class="type">Range</span> )&#123;</span><br><span class="line">   statement(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举个例子「🌰」例1：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> r = <span class="type">Range</span>(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">r: scala.collection.immutable.<span class="type">Range</span> = <span class="type">Range</span>(<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">for</span>( x&lt;- r)&#123;</span><br><span class="line">     | println(x)</span><br><span class="line">     | &#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><strong>遍历一个Map，例2</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = <span class="type">Map</span>(<span class="string">"fname"</span> -&gt; <span class="string">"Robert"</span>,<span class="string">"lname"</span>-&gt;<span class="string">"Goren"</span>)</span><br><span class="line"><span class="keyword">for</span>((k,v)&lt;-names)&#123;</span><br><span class="line">    println(<span class="string">s"key:<span class="subst">$k</span>,value:<span class="subst">$v</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多种循环：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x &lt;- <span class="type">Range</span>; y&lt;- <span class="type">Range</span> )&#123;</span><br><span class="line">   statement(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0x11-while循环"><a href="#0x11-while循环" class="headerlink" title="0x11 while循环"></a>0x11 while循环</h5><p>表达式如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">   statement(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">i: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">while</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">     |     println(i)</span><br><span class="line">     |     i += <span class="number">1</span></span><br><span class="line">     | &#125;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><strong>多重循环条件:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition1)&#123;</span><br><span class="line">   <span class="keyword">while</span>(condition2)</span><br><span class="line">      statement(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="0x12-do…while循环"><a href="#0x12-do…while循环" class="headerlink" title="0x12 do…while循环"></a>0x12 do…while循环</h5><p>while 与 do…while循环类似</p><p>表达式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">   statement(x);</span><br><span class="line">&#125;<span class="keyword">while</span>(condition)</span><br></pre></td></tr></table></figure><h4 id="0x2-循环中的卫语句"><a href="#0x2-循环中的卫语句" class="headerlink" title="0x2 循环中的卫语句"></a>0x2 循环中的卫语句</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;循环中的卫语句即在for循环中嵌入if语句，我们在业务开发中，在遍历过程中需要根据if 条件进行不同逻辑处理，比如过滤掉某些项。通常的做法是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Scala中，我们可以这样写:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span> <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样写</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    i &lt;- <span class="number">1</span> to <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125; println(i)</span><br></pre></td></tr></table></figure><p><strong>表达式语法：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    loop</span><br><span class="line">    condition1</span><br><span class="line">    condition2</span><br><span class="line">    ...</span><br><span class="line">&#125; statement();</span><br></pre></td></tr></table></figure><h4 id="0x3-yield语法"><a href="#0x3-yield语法" class="headerlink" title="0x3 yield语法"></a>0x3 yield语法</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;通过yield语法生成新的集合（PS：通常原集合是什么类型，生成的集合就是什么类型），假设有一个数组，数组值都是小写的字符串，将其进行首字母大写处理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="string">"delete"</span>,<span class="string">"scala"</span>,<span class="string">"zt"</span>)</span><br><span class="line"><span class="keyword">val</span> arr_yield = <span class="keyword">for</span> (i&lt;-arr) <span class="keyword">yield</span> i.capitalize</span><br><span class="line"></span><br><span class="line">scala&gt; arr_yield.foreach(println)</span><br><span class="line"><span class="type">Delete</span></span><br><span class="line"><span class="type">Scala</span></span><br><span class="line"><span class="type">Zt</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h4 id="0x4-break-amp-continue"><a href="#0x4-break-amp-continue" class="headerlink" title="0x4 break &amp; continue"></a>0x4 break &amp; continue</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;与Java和其他语言不通，在Scala中break 一种方法，而不是一个关键字，在Scala中需用用到 breakable及break两个方法，由break抛出异常，breakable进行异常捕获，由此实现break &amp; continue功能，下面看一个例子：</p><p><strong>例1：break实现</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breakable&#123;</span><br><span class="line">    <span class="keyword">for</span>(i&lt;- <span class="number">1</span> to <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">break</span>  # 将跳出循环 实现<span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例2：continue实现</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;- <span class="number">1</span> to <span class="number">10</span>)&#123;</span><br><span class="line">    breakable&#123;</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">break</span>  # 跳出当前，继续下一遍历</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在scala.util.control.breaks类中，有非常清晰的定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A block from which one can exit with a `break`. The `break` may be</span></span><br><span class="line"><span class="comment">   * executed further down in the call stack provided that it is called on the</span></span><br><span class="line"><span class="comment">   * exact same instance of `Breaks`.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">breakable</span></span>(op: =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      op</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">BreakControl</span> =&gt;</span><br><span class="line">        <span class="keyword">if</span> (ex ne breakException) <span class="keyword">throw</span> ex</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Break from dynamically closest enclosing breakable block using this exact</span></span><br><span class="line"><span class="comment">   * `Breaks` instance.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @note This might be different than the statically closest enclosing block!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">break</span></span>(): <span class="type">Nothing</span> = &#123; <span class="keyword">throw</span> breakException &#125;</span><br></pre></td></tr></table></figure><p>由break函数抛出异常，由breakable捕获异常</p><h4 id="0xF-总结"><a href="#0xF-总结" class="headerlink" title="0xF 总结"></a>0xF 总结</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;循环结构与其他语言大同小异，Scala中更加简洁的表达方式是其一大亮点，学习Scala可能需要多适应Scala语言的表达方式才能理解，当然是用常规的方式进行表达也不会有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;今天学习的内容是循环，循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：&lt;br&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2015/12/loop.png&quot; alt=&quot;loop.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x01 一起来学Scala" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x01-%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Scala/"/>
    
    
      <category term="Scala" scheme="http://deletee.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Hive窗口函数</title>
    <link href="http://deletee.top/2019/01/20/how-to-use-window-func/"/>
    <id>http://deletee.top/2019/01/20/how-to-use-window-func/</id>
    <published>2019-01-20T13:48:30.000Z</published>
    <updated>2019-01-26T13:16:18.726Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;窗口函数常常用于我们业务中的复杂计算，本文介绍Hive中几个常用的窗口函数，并用案例讲述如何使用。那么我们常用的窗口函数有哪些？</p><div class="table-container"><table><thead><tr><th>函数名</th><th>备注</th></tr></thead><tbody><tr><td>row_number</td><td>分组内根据排列条件从1开始的排序，没有相同的序号</td></tr><tr><td>rank</td><td>分组内根据排列条件从1开始的排序，排名相等会在名次中留下空位，例如：1，2，2，4</td></tr><tr><td>dense_rank</td><td>分组内根据排列条件从1开始的排序，排名相等会在名次中不会留下空位，例如：1，2，2，3</td></tr><tr><td>lag</td><td>分组内根据排列条件取前第n个值</td></tr><tr><td>lead</td><td>分组内根据排列条件取后第n个值，与 lag相反</td></tr><tr><td>first_value</td><td>分组内根据排列条件去分组第一个值</td></tr><tr><td>last_value</td><td>分组内根据排列条件去分组最后一个值</td></tr><tr><td>min</td><td>分组内取最小值</td></tr><tr><td>max</td><td>分组内取最大值</td></tr><tr><td>sum</td><td>分组内取分组值的和</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><a id="more"></a><p>PS: 所有的窗口函数都将是生成的一个新列，并不会对原有数据列造成影响</p><p>下面将一一这些函数的使用。</p><h4 id="0x0-row-number"><a href="#0x0-row-number" class="headerlink" title="0x0 row_number"></a>0x0 row_number</h4><p>row_number 可以说是最常用的一个窗口函数。</p><p>举个栗子「🌰」：我们有一组数据，是一个班级一学期4次数学月考的成绩表 <code>score</code></p><div class="table-container"><table><thead><tr><th>学生ID(sid)</th><th>第几次月考（exam_time）</th><th>成绩(score)</th></tr></thead><tbody><tr><td>s001</td><td>1</td><td>83</td></tr><tr><td>s001</td><td>2</td><td>87</td></tr><tr><td>s001</td><td>3</td><td>84</td></tr><tr><td>s001</td><td>4</td><td>89</td></tr><tr><td>s002</td><td>1</td><td>90</td></tr><tr><td>s002</td><td>2</td><td>75</td></tr><tr><td>s002</td><td>3</td><td>89</td></tr><tr><td>s002</td><td>4</td><td>82</td></tr></tbody></table></div><p><strong>那么Question：请问每个学生4次月考成绩中最好的一次是哪一次月考？</strong></p><p>此时，max的手法是不能够使用了，如果解决上述问题？实际上是将根据每个学生进行分组，即每个学生的4次月考为一组，那么计算这个分组成绩中的最大值即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">      <span class="keyword">sid</span></span><br><span class="line">     ,exam_time</span><br><span class="line">     ,score</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">sid</span></span><br><span class="line">          ,exam_time</span><br><span class="line">          ,score</span><br><span class="line">          ,row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">sid</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> r_idx</span><br><span class="line">    <span class="keyword">from</span> score</span><br><span class="line">)t </span><br><span class="line"><span class="keyword">where</span> t.r_idx = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>我们称 row_number 为窗口函数，over为从句，窗口函数与over配合使用</p><p>1、使用PARTITION BY语句，使用一个或者多个原始数据类型的列进行分组<br>2、使用ORDER BY语句，使用一个或者多个数据类型的排序列 </p><p>反过来over 中若不指定 partition by 的数据列，那么整个表作为一个默认分组，同理不指定 order by 那么默认当前顺序，<strong>大家先只需了解这两点，熟练之后可以学习第三点</strong>。</p><p>3、使用窗口规范，窗口规范支持以下格式：</p><p>(ROWS | RANGE) BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)<br>(ROWS | RANGE) BETWEEN CURRENT ROW AND (CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)<br>(ROWS | RANGE) BETWEEN [num] FOLLOWING AND (UNBOUNDED | [num]) FOLLOWING</p><p>详细参考文档：<a href="https://cwiki.apache.org/confluence/display/ASTERIXDB/Window+Functions" target="_blank" rel="noopener">Hive官方参考文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;窗口函数常常用于我们业务中的复杂计算，本文介绍Hive中几个常用的窗口函数，并用案例讲述如何使用。那么我们常用的窗口函数有哪些？&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;row_number&lt;/td&gt;
&lt;td&gt;分组内根据排列条件从1开始的排序，没有相同的序号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rank&lt;/td&gt;
&lt;td&gt;分组内根据排列条件从1开始的排序，排名相等会在名次中留下空位，例如：1，2，2，4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dense_rank&lt;/td&gt;
&lt;td&gt;分组内根据排列条件从1开始的排序，排名相等会在名次中不会留下空位，例如：1，2，2，3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lag&lt;/td&gt;
&lt;td&gt;分组内根据排列条件取前第n个值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lead&lt;/td&gt;
&lt;td&gt;分组内根据排列条件取后第n个值，与 lag相反&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;first_value&lt;/td&gt;
&lt;td&gt;分组内根据排列条件去分组第一个值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;last_value&lt;/td&gt;
&lt;td&gt;分组内根据排列条件去分组最后一个值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;min&lt;/td&gt;
&lt;td&gt;分组内取最小值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max&lt;/td&gt;
&lt;td&gt;分组内取最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sum&lt;/td&gt;
&lt;td&gt;分组内取分组值的和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x2 技术平台" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="1x21 Hive" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/1x21-Hive/"/>
    
    
      <category term="Hive" scheme="http://deletee.top/tags/Hive/"/>
    
      <category term="SQL" scheme="http://deletee.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>ftp上传目录的方法</title>
    <link href="http://deletee.top/2019/01/16/ftp-upload-folder/"/>
    <id>http://deletee.top/2019/01/16/ftp-upload-folder/</id>
    <published>2019-01-16T12:41:30.000Z</published>
    <updated>2019-01-26T13:16:00.449Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，使用ftp命令是不能够直接上传文件夹的，然后工作中有很多需要上传目录的场景，通常大家想到的就是先创建文件夹，然后再通过遍历的方式上传文件，其中比较繁琐的是，ftp里不支持，多层级目录直接创建，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deletee:$ mkdir -p $&#123;dir&#125;/$&#123;subdir&#125;</span><br></pre></td></tr></table></figure></p><p>这样的方式，只能逐级创建，将造成很多工作量。下面将分享下如何快速有效的实现上传ftp文件夹</p><a id="more"></a><h4 id="0x0-生成创建多级文件夹命令"><a href="#0x0-生成创建多级文件夹命令" class="headerlink" title="0x0 生成创建多级文件夹命令"></a>0x0 生成创建多级文件夹命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export mkdir_cmds=`find $&#123;upload_folder&#125; -type d -printf '%P\n' \</span><br><span class="line">          |awk '&#123; \</span><br><span class="line">               split($0,a,"/");            \</span><br><span class="line">               for (i in a) &#123;              \</span><br><span class="line">                  cmds ="mkdir ";          \</span><br><span class="line">                  for (j=1;j&lt;=i;j++) &#123;     \</span><br><span class="line">                      cmds = cmds"/"a[j]   \</span><br><span class="line">                  &#125; print cmds             \</span><br><span class="line">              &#125;                            \</span><br><span class="line">          &#125;'                               \</span><br><span class="line">          |sort|uniq`</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">deletee@pig_house:~/logon_log/bin$ ls -lh</span><br><span class="line">total 48K</span><br><span class="line">-rwxr-xr-x 1 delete pig_house  324 Jan  9 14:59 clearftpfile.sh</span><br><span class="line">-rwxr-xr-x 1 delete pig_house 2.2K Jan 11 12:19 contact_send.sh</span><br><span class="line">-rwxr-xr-x 1 delete pig_house 5.7K Jan  9 14:59 handle_file_repair.sh</span><br><span class="line">-rwxr-xr-x 1 delete pig_house 7.9K Jan 10 10:29 handle_file.sh</span><br><span class="line">drwxr-xr-x 3 delete pig_house 4.0K Jan 14 15:59 logon</span><br><span class="line">-rwxr-xr-x 1 delete pig_house 2.2K Jan 11 12:18 mail_send.sh</span><br><span class="line">-rwxr-xr-x 1 delete pig_house 2.2K Jan 11 12:18 news_send.sh</span><br><span class="line">drwxr-xr-x 3 delete pig_house 4.0K Jan 11 12:19 reg</span><br><span class="line">-rwxr-xr-x 1 delete pig_house 1.4K Jan  9 14:59 repair_login.sh</span><br><span class="line">-rwxr-xr-x 1 delete pig_house 2.8K Jan 16 14:50 send_news.sh</span><br><span class="line"></span><br><span class="line">deletee@pig_house:~/logon_log/bin$ upload_folder="bin"</span><br><span class="line">deletee@pig_house:~/logon_log/bin$ find $&#123;upload_folder&#125; -type d -printf '%P\n' \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">           |awk <span class="string">'&#123; \</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                split(<span class="variable">$0</span>,a,<span class="string">"/"</span>);            \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                <span class="keyword">for</span> (i <span class="keyword">in</span> a) &#123;              \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   cmds =<span class="string">"mkdir /<span class="variable">$&#123;upload_folder&#125;</span>"</span>;          \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   <span class="keyword">for</span> (j=1;j&lt;=i;j++) &#123;     \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                       cmds = cmds<span class="string">"/"</span>a[j]   \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   &#125; <span class="built_in">print</span> cmds             \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">               &#125;                            \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">           &#125;<span class="string">'                               \</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">           |sort|uniq</span></span><br><span class="line">mkdir /bin/logon</span><br><span class="line">mkdir /bin/logon/bak</span><br><span class="line">mkdir /bin/reg</span><br><span class="line">mkdir /bin/reg/bak</span><br></pre></td></tr></table></figure><h4 id="0x1-生成put文件命令"><a href="#0x1-生成put文件命令" class="headerlink" title="0x1 生成put文件命令"></a>0x1 生成put文件命令</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理与创建文件夹命令类似<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export put_cmds=`find $&#123;upload_folder&#125; -type f -printf 'put %p $&#123;ftp_target_folder&#125;/%P\n'`</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deletee@pig_house:upload_path='~/logon_log/bin'</span><br><span class="line">deletee@pig_house:upload_folder='bin'</span><br><span class="line">deletee@pig_house:ftp_target_path='/ftp'</span><br><span class="line"></span><br><span class="line">deletee@pig_house:find $&#123;upload_path&#125; -type f -printf 'put %p $&#123;ftp_target_path&#125;/%P\n'</span><br><span class="line">put ./bin/logon/bak/police-logon.jar.bak /ftp/bin/logon/bak/police-logon.jar.bak</span><br><span class="line">put ./bin/logon/bak/run.sh /ftp/bin/logon/bak/run.sh</span><br><span class="line">put ./bin/logon/bak/stop.sh /ftp/bin/logon/bak/stop.sh</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="0x2-一个栗子"><a href="#0x2-一个栗子" class="headerlink" title="0x2 一个栗子"></a>0x2 一个栗子</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">upload_path=$1        # 待上传目录</span><br><span class="line">ftp_target_path=$2    # ftp目标目录</span><br><span class="line"></span><br><span class="line">upload_folder=`basename $&#123;upload_path&#125;`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export mkdir_cmds=`find $&#123;upload_path&#125; -type d -printf '%P\n' \</span><br><span class="line">          |awk '&#123; \</span><br><span class="line">               split($0,a,"/");            \</span><br><span class="line">               for (i in a) &#123;              \</span><br><span class="line">                  cmds ="mkdir $&#123;upload_folder&#125;";          \</span><br><span class="line">                  for (j=1;j&lt;=i;j++) &#123;     \</span><br><span class="line">                      cmds = cmds"/"a[j]   \</span><br><span class="line">                  &#125; print cmds             \</span><br><span class="line">              &#125;                            \</span><br><span class="line">          &#125;'                               \</span><br><span class="line">          |sort|uniq`</span><br><span class="line"></span><br><span class="line">export put_cmds=`find $&#123;upload_path&#125; -type f -printf 'put %p $&#123;ftp_target_folder&#125;/%P\n'`</span><br><span class="line"></span><br><span class="line">ftp_host=</span><br><span class="line">ftp_port=</span><br><span class="line">ftp_username=</span><br><span class="line">ftp_password=</span><br><span class="line">ftp -i -n &lt;&lt; EOF</span><br><span class="line">open $ftp_host $ftp_port</span><br><span class="line">user $ftp_username $ftp_password</span><br><span class="line">bi</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;mkdir_cmds&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;put_cmds&#125;</span></span><br><span class="line">bye</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="0XF-总结"><a href="#0XF-总结" class="headerlink" title="0XF 总结"></a>0XF 总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用生成ftp命令的方式，避免多层级及不定层级目录的创建ftp目录的繁琐。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家觉得怎么样？或是有更好的方法！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;众所周知，使用ftp命令是不能够直接上传文件夹的，然后工作中有很多需要上传目录的场景，通常大家想到的就是先创建文件夹，然后再通过遍历的方式上传文件，其中比较繁琐的是，ftp里不支持，多层级目录直接创建，&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deletee:$ mkdir -p $&amp;#123;dir&amp;#125;/$&amp;#123;subdir&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样的方式，只能逐级创建，将造成很多工作量。下面将分享下如何快速有效的实现上传ftp文件夹&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x00 一起来学Shell" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x00-%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Shell/"/>
    
    
      <category term="shell" scheme="http://deletee.top/tags/shell/"/>
    
      <category term="awk" scheme="http://deletee.top/tags/awk/"/>
    
      <category term="ftp" scheme="http://deletee.top/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>一起来学Scala(3)-字符串</title>
    <link href="http://deletee.top/2019/01/10/scala-programing-string/"/>
    <id>http://deletee.top/2019/01/10/scala-programing-string/</id>
    <published>2019-01-10T15:30:50.000Z</published>
    <updated>2019-01-26T13:16:51.254Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文中已经介绍了Scala语言中的基本类型，本文着重介绍下字符串的用法，字符串在我们日常开发中经常用到，字符串在Scala中的类型<code>String</code>，那么Scala中的String和Java中的String有什么关系呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="string">"Scala"</span>.getClass.getName</span><br><span class="line">res0: <span class="type">String</span> = java.lang.<span class="type">String</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本以为Scala是怎样实现了String，上述代码中告诉我们Scala中的<code>String</code>竟就是Java中的<code>String</code>。我们接下更深层次的学习<code>String</code>。<br><img src="/images/a311e33c02d299ee621f10649459ac73.png" alt="a311e33c02d299ee621f10649459ac73"><br><a id="more"></a></p><h4 id="0x0-基本用法"><a href="#0x0-基本用法" class="headerlink" title="0x0 基本用法"></a>0x0 基本用法</h4><h5 id="0x00-长度-length"><a href="#0x00-长度-length" class="headerlink" title="0x00 长度 .length"></a>0x00 长度 .length</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> str = <span class="string">"Scala"</span></span><br><span class="line">str: <span class="type">String</span> = <span class="type">Scala</span></span><br><span class="line"></span><br><span class="line">scala&gt; str.length</span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过 .length的方式可获取变量str的长度</p><h5 id="0x01-遍历"><a href="#0x01-遍历" class="headerlink" title="0x01 遍历"></a>0x01 遍历</h5><p><strong>第一种方式:</strong> 通过遍历字符串的每一个字符</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span>(c &lt;- str) &#123; println(c) &#125;</span><br><span class="line"><span class="type">S</span></span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">l</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种方式:</strong> 通过调用.foreach方法，入参 println函数实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; str.foreach(println)</span><br><span class="line"><span class="type">S</span></span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">l</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><strong>第三种方式:</strong> 通过调用.map方法，入参 println函数实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; str.map(println)</span><br><span class="line"><span class="type">S</span></span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">l</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h5 id="0x02-过滤-filter"><a href="#0x02-过滤-filter" class="headerlink" title="0x02 过滤 .filter"></a>0x02 过滤 .filter</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; str.filter(_ != 'a')</span><br><span class="line">res10: <span class="type">String</span> = <span class="type">Scl</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h5 id="0x03-Bytes数组-getBytes"><a href="#0x03-Bytes数组-getBytes" class="headerlink" title="0x03 Bytes数组 .getBytes"></a>0x03 Bytes数组 .getBytes</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; str.getBytes</span><br><span class="line">res11: <span class="type">Array</span>[<span class="type">Byte</span>] = <span class="type">Array</span>(<span class="number">83</span>, <span class="number">99</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">97</span>)</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>0x0F 小结</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code>有很多的方法，例如 <code>.drop(n)</code> 删除前面n个字符,<code>.take(n)</code>取前n个字符，<code>.captitalize</code> 将字符串转为大写(与 .toUpperCase 功能等同)等等。</p><h4 id="0x1-字符串相等性"><a href="#0x1-字符串相等性" class="headerlink" title="0x1 字符串相等性"></a>0x1 字符串相等性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何比较两个字符串是否相等</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> str1 = <span class="string">"Scala"</span></span><br><span class="line">str1: <span class="type">String</span> = <span class="type">Scala</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> str2 = <span class="string">"S"</span> + <span class="string">"cala"</span></span><br><span class="line">str2: <span class="type">String</span> = <span class="type">Scala</span></span><br><span class="line"></span><br><span class="line">scala&gt; str1 == str2</span><br><span class="line">res12: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上，两个字符串内容是相等的,通过<code>==</code> 可判断两个字符串内容是否相等，这与Java中使用equal的方法比较两个对象不同。在Java中需要先判断调用的对象是否为null，即在AnyRef类使用时，Scala也会判断调用是否是null，其他情况下是不需要判断变量是否为null。实际上在Scala开发过程中，不推荐定义null，</p><h4 id="0x2-创建多行字符串"><a href="#0x2-创建多行字符串" class="headerlink" title="0x2 创建多行字符串"></a>0x2 创建多行字符串</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一点与Python类似，可以通过三个双引号来定义，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> multi_line_str = <span class="string">""</span><span class="string">"Hello,</span></span><br><span class="line"><span class="string">     |                         I love Scala"</span><span class="string">""</span></span><br><span class="line">multi_line_str: <span class="type">String</span> =</span><br><span class="line"><span class="type">Hello</span>,</span><br><span class="line">                        <span class="type">I</span> love <span class="type">Scala</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>显示第二行是一连串的空格，我们可以使用管道的方式，与Python类似</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> multi_line_str = <span class="string">""</span><span class="string">"Hello,</span></span><br><span class="line"><span class="string">     | I love Scala</span></span><br><span class="line"><span class="string">     | "</span><span class="string">""</span></span><br><span class="line">multi_line_str: <span class="type">String</span> =</span><br><span class="line"><span class="string">"Hello,</span></span><br><span class="line"><span class="string">I love Scala</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> multi_line_str = <span class="string">""</span><span class="string">"Hello,</span></span><br><span class="line"><span class="string">     | I love Scala</span></span><br><span class="line"><span class="string">     | "</span><span class="string">""</span>.stripMargin</span><br><span class="line">multi_line_str: <span class="type">String</span> =</span><br><span class="line"><span class="string">"Hello,</span></span><br><span class="line"><span class="string">I love Scala</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>如果不喜欢使用管道 <code>|</code>可以使用其他符号表示，例如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> multi_line_str = <span class="string">""</span><span class="string">"Hello,</span></span><br><span class="line"><span class="string">     @ I love Scala</span></span><br><span class="line"><span class="string">     @ "</span><span class="string">""</span>.stripMargin('@')</span><br><span class="line">multi_line_str: <span class="type">String</span> =</span><br><span class="line"><span class="string">"Hello,</span></span><br><span class="line"><span class="string">I love Scala</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h4 id="0x3-变量代换"><a href="#0x3-变量代换" class="headerlink" title="0x3 变量代换"></a>0x3 变量代换</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类似于Python一样，使用变量的值代换进另一个字符串</p><h5 id="0x30-s是一个方法"><a href="#0x30-s是一个方法" class="headerlink" title="0x30 s是一个方法"></a>0x30 s是一个方法</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> name = <span class="string">"deleee"</span></span><br><span class="line">name: <span class="type">String</span> = deleee</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> setence = <span class="string">s"My name is <span class="subst">$name</span>"</span></span><br><span class="line">setence: <span class="type">String</span> = <span class="type">My</span> name is deleee</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整形变量可以做计算，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> age = <span class="number">2</span></span><br><span class="line">age: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> setence1 = <span class="string">s"My age is <span class="subst">$&#123;age + 1&#125;</span>"</span></span><br><span class="line">setence1: <span class="type">String</span> = <span class="type">My</span> age is <span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h5 id="0x31-字符串差值-printf"><a href="#0x31-字符串差值-printf" class="headerlink" title="0x31 字符串差值(printf)"></a>0x31 字符串差值(printf)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 即我们常在C语言或者Python中的数值格式化，需要在字符串前使用<code>f</code>标识</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> setence2 = <span class="string">f"My age is <span class="subst">$&#123;age + 1&#125;</span>%.2f"</span></span><br><span class="line">setence2: <span class="type">String</span> = <span class="type">My</span> age is <span class="number">3.00</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><code>%.2f</code>表示将数值进行小数点后2位精度</p><div class="table-container"><table><thead><tr><th>格式化符号</th><th>描述</th></tr></thead><tbody><tr><td>%c</td><td>字符</td></tr><tr><td>%d</td><td>整数 与 %i 相同</td></tr><tr><td>%e</td><td>指数浮点型</td></tr><tr><td>%f</td><td>浮点型</td></tr><tr><td>%i</td><td>整数</td></tr><tr><td>%o</td><td>八进制</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%u</td><td>无符号整形</td></tr><tr><td>%x</td><td>十六进制</td></tr><tr><td>%% 或者 \%</td><td>输出一个百分号</td></tr></tbody></table></div><h4 id="0x4-正则表达式"><a href="#0x4-正则表达式" class="headerlink" title="0x4 正则表达式"></a>0x4 正则表达式</h4><h5 id="0x40-创建正则表达式"><a href="#0x40-创建正则表达式" class="headerlink" title="0x40 创建正则表达式"></a>0x40 创建正则表达式</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在字符串末尾使用<code>.r</code>即表示创建的为一个Regex对象，随后可以用<code>.findFirstIn</code>匹配第一个，<code>.findAllIn</code>来匹配所有的。</p><p><strong>例如:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> numPatten = <span class="string">"[0-9]+"</span>.r</span><br><span class="line">numPatten: scala.util.matching.<span class="type">Regex</span> = [<span class="number">0</span><span class="number">-9</span>]+</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> str = <span class="string">"123 is not 321"</span></span><br><span class="line">str: <span class="type">String</span> = <span class="number">123</span> is not <span class="number">321</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> match1 = numPatten.findFirstIn(str)</span><br><span class="line">match1: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; numPatten.findAllIn(str).foreach(println)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">321</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><strong>或者：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.util.matching.<span class="type">Regex</span></span><br><span class="line"><span class="keyword">import</span> scala.util.matching.<span class="type">Regex</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> pattern = <span class="keyword">new</span> <span class="type">Regex</span>(<span class="string">"(S|s)cala"</span>)</span><br><span class="line">pattern: scala.util.matching.<span class="type">Regex</span> = (<span class="type">S</span>|s)cala</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><strong>PS:关注下返回类型</strong></p><p>（1）<code>.findFirstIn</code> 返回的一个是Some类型的变量，我们可以简单的认为Some是一个容器，匹配成功则返回数字，匹配不成功就返回None</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> numPatten = <span class="string">"[0-9]+"</span>.r</span><br><span class="line">numPatten: scala.util.matching.<span class="type">Regex</span> = [<span class="number">0</span><span class="number">-9</span>]+</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> str = <span class="string">"not number"</span></span><br><span class="line">str: <span class="type">String</span> = not number</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> match1 = numPatten.findFirstIn(str)</span><br><span class="line">match1: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>（2）<code>.findAllIn</code>返回的是一个迭代器，可使用foreach方法进行遍历，也可以将迭代器转为数组,例如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> matchArr = numPatten.findAllIn(str).toArray</span><br><span class="line">matchArr: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(<span class="number">123</span>, <span class="number">321</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">for</span> ( a &lt;- matchArr) println(a)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">321</span></span><br><span class="line"></span><br><span class="line">scala&gt; matchArr.foreach(println)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">321</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h5 id="0x41-字符串替换"><a href="#0x41-字符串替换" class="headerlink" title="0x41 字符串替换"></a>0x41 字符串替换</h5><p>常规的替换手法字符串调用方法<code>.replaceAll</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> str = <span class="string">"123 is not 321"</span></span><br><span class="line">str: <span class="type">String</span> = <span class="number">123</span> is not <span class="number">321</span></span><br><span class="line"></span><br><span class="line">scala&gt; str.replaceAll(<span class="string">"[1-9]+"</span>,<span class="string">"sss"</span>)</span><br><span class="line">res12: <span class="type">String</span> = sss is not sss</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>也可以使用正则表达式作为对象调用方法 <code>.replaceAllIn</code>及<code>.replaceFirstIn</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> numPatten = <span class="string">"[0-9]+"</span>.r</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> str = <span class="string">"123 is not 321"</span></span><br><span class="line">str: <span class="type">String</span> = <span class="number">123</span> is not <span class="number">321</span></span><br><span class="line"></span><br><span class="line">scala&gt; numPatten.replaceAllIn(str,<span class="string">"sss"</span>)</span><br><span class="line">res13: <span class="type">String</span> = sss is not sss</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h5 id="0x42-字符串抽取"><a href="#0x42-字符串抽取" class="headerlink" title="0x42 字符串抽取"></a>0x42 字符串抽取</h5><p>正则表达式中使用() 表示 匹配的组，与其他（Perl、Python表达式相同）</p><p><strong>例如：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.util.matching.<span class="type">Regex</span></span><br><span class="line"><span class="keyword">import</span> scala.util.matching.<span class="type">Regex</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> numberPattern: <span class="type">Regex</span> = <span class="string">"[0-9]"</span>.r</span><br><span class="line">numberPattern: scala.util.matching.<span class="type">Regex</span> = [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line"></span><br><span class="line">scala&gt; numberPattern.findFirstMatchIn(<span class="string">"awesomepassword"</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">     |   <span class="keyword">case</span> <span class="type">Some</span>(_) =&gt; println(<span class="string">"Password OK"</span>)</span><br><span class="line">     |   <span class="keyword">case</span> <span class="type">None</span> =&gt; println(<span class="string">"Password must contain a number"</span>)</span><br><span class="line">     | &#125;</span><br><span class="line"><span class="type">Password</span> must contain a number</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="keyword">import</span> scala.util.matching.<span class="type">Regex</span></span><br><span class="line">scala&gt;<span class="keyword">val</span> keyValPattern: <span class="type">Regex</span> = <span class="string">"([0-9a-zA-Z-#() ]+): ([0-9a-zA-Z-#() ]+)"</span>.r</span><br><span class="line">scala&gt;<span class="keyword">val</span> input: <span class="type">String</span> =</span><br><span class="line">    <span class="string">""</span><span class="string">"background-color: #A03300;</span></span><br><span class="line"><span class="string">     |background-image: url(img/header100.png);</span></span><br><span class="line"><span class="string">     |background-position: top center;</span></span><br><span class="line"><span class="string">     |background-repeat: repeat-x;</span></span><br><span class="line"><span class="string">     |background-size: 2160px 108px;</span></span><br><span class="line"><span class="string">     |margin: 0;</span></span><br><span class="line"><span class="string">     |height: 108px;</span></span><br><span class="line"><span class="string">     |width: 100%;"</span><span class="string">""</span>.stripMargin</span><br><span class="line">scala&gt;<span class="keyword">for</span> (patternMatch &lt;- keyValPattern.findAllMatchIn(input))</span><br><span class="line">     | println(<span class="string">s"key: <span class="subst">$&#123;patternMatch.group(1)&#125;</span> value: <span class="subst">$&#123;patternMatch.group(2)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">key: background-color value: #<span class="type">A03300</span></span><br><span class="line">key: background-image value: url(img</span><br><span class="line">key: background-position value: top center</span><br><span class="line">key: background-repeat value: repeat-x</span><br><span class="line">key: background-size value: <span class="number">2160</span>px <span class="number">108</span>px</span><br><span class="line">key: margin value: <span class="number">0</span></span><br><span class="line">key: height value: <span class="number">108</span>px</span><br><span class="line">key: width value: <span class="number">100</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>更多更详细的内容请参考<a href="https://blog.csdn.net/smile_from_2015/article/details/80337535" target="_blank" rel="noopener">Scala之旅-正则表达式模式和提取器对象（EXTRACTOR OBJECTS）</a></p><h5 id="0x4E-正则表达式"><a href="#0x4E-正则表达式" class="headerlink" title="0x4E 正则表达式"></a>0x4E 正则表达式</h5><p>Scala 的正则表达式继承了 Java 的语法规则，Java 则大部分使用了 Perl 语言的规则。</p><p>下表我们给出了常用的一些正则表达式规则：</p><div class="table-container"><table><thead><tr><th>表达式</th><th>匹配规则</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串开始的位置。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。</td></tr><tr><td>.</td><td>匹配除”\r\n”之外的任何单个字符。</td></tr><tr><td>[…]</td><td>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td></tr><tr><td><sup><a href="#fn_..." id="reffn_...">...</a></sup></td><td>反向字符集。匹配未包含的任何字符。例如，”<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>“匹配”plain”中”p”，”l”，”i”，”n”。</td></tr><tr><td>\\A</td><td>匹配输入字符串开始的位置（无多行支持）</td></tr><tr><td>\\z</td><td>字符串结尾(类似$，但不受处理多行选项的影响)</td></tr><tr><td>\\Z</td><td>字符串结尾或行尾(不受处理多行选项的影响)</td></tr><tr><td>re*</td><td>重复零次或更多次</td></tr><tr><td>re+</td><td>重复一次或更多次</td></tr><tr><td>re?</td><td>重复零次或一次</td></tr><tr><td>re{ n}</td><td>重复n次</td></tr><tr><td>re{ n,}</td><td></td></tr><tr><td>re{ n, m}</td><td>重复n到m次</td></tr><tr><td>a\</td><td>b</td><td>匹配 a 或者 b</td></tr><tr><td>(re)</td><td>匹配 re,并捕获文本到自动命名的组里</td></tr><tr><td>(?: re)</td><td>匹配 re,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>(?&gt; re)</td><td>贪婪子表达式</td></tr><tr><td>\\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\\s</td><td>匹配任意的空白符,相等于 [\t\n\r\f]</td></tr><tr><td>\\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\\d</td><td>匹配数字，类似 [0-9]</td></tr><tr><td>\\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\\G</td><td>当前搜索的开头</td></tr><tr><td>\\n</td><td>换行符</td></tr><tr><td>\\b</td><td>通常是单词分界位置，但如果在字符类里使用代表退格</td></tr><tr><td>\\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>\\t</td><td>制表符</td></tr><tr><td>\\Q</td><td>开始引号：<strong>\Q(a+b)*3\E</strong> 可匹配文本 “(a+b)*3”。</td></tr><tr><td>\\E</td><td>结束引号：<strong>\Q(a+b)*3\E</strong> 可匹配文本 “(a+b)*3”。</td></tr></tbody></table></div><h5 id="0x4F-正则表达式实例"><a href="#0x4F-正则表达式实例" class="headerlink" title="0x4F 正则表达式实例"></a>0x4F 正则表达式实例</h5><div class="table-container"><table><thead><tr><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>匹配除”\r\n”之外的任何单个字符。</td></tr><tr><td>[Rr]uby</td><td>匹配 “Ruby” 或 “ruby”</td></tr><tr><td>rub[ye]</td><td>匹配 “ruby” 或 “rube”</td></tr><tr><td>[aeiou]</td><td>匹配小写字母 ：aeiou</td></tr><tr><td>[0-9]</td><td>匹配任何数字，类似 [0123456789]</td></tr><tr><td>[a-z]</td><td>匹配任何 ASCII 小写字母</td></tr><tr><td>[A-Z]</td><td>匹配任何 ASCII 大写字母</td></tr><tr><td>[a-zA-Z0-9]</td><td>匹配数字，大小写字母</td></tr><tr><td><sup><a href="#fn_aeiou" id="reffn_aeiou">aeiou</a></sup></td><td>匹配除了 aeiou 其他字符</td></tr><tr><td><sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup></td><td>匹配除了数字的其他字符</td></tr><tr><td>\\d</td><td>匹配数字，类似: [0-9]</td></tr><tr><td>\\D</td><td>匹配非数字，类似: <sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup></td></tr><tr><td>\\s</td><td>匹配空格，类似: [ \t\r\n\f]</td></tr><tr><td>\\S</td><td>匹配非空格，类似: <sup><a href="#fn_ \t\r\n\f" id="reffn_ \t\r\n\f"> \t\r\n\f</a></sup></td></tr><tr><td>\\w</td><td>匹配字母，数字，下划线，类似: [A-Za-z0-9_]</td></tr><tr><td>\\W</td><td>匹配非字母，数字，下划线，类似: <sup><a href="#fn_A-Za-z0-9_" id="reffn_A-Za-z0-9_">A-Za-z0-9_</a></sup></td></tr><tr><td>ruby?</td><td>匹配 “rub” 或 “ruby”: y 是可选的</td></tr><tr><td>ruby*</td><td>匹配 “rub” 加上 0 个或多个的 y。</td></tr><tr><td>ruby+</td><td>匹配 “rub” 加上 1 个或多个的 y。</td></tr><tr><td>\\d{3}</td><td>刚好匹配 3 个数字。</td></tr><tr><td>\\d{3,}</td><td>匹配 3 个或多个数字。</td></tr><tr><td>\\d{3,5}</td><td>匹配 3 个、4 个或 5 个数字。</td></tr><tr><td>\\D\\d+</td><td>无分组： + 重复 \d</td></tr><tr><td>(\\D\\d)+/</td><td>分组： + 重复 \D\d 对</td></tr><tr><td>([Rr]uby(, )?)+</td><td>匹配 “Ruby”、”Ruby, ruby, ruby”，等等</td></tr></tbody></table></div><h4 id="0x5-自定义方法"><a href="#0x5-自定义方法" class="headerlink" title="0x5 自定义方法"></a>0x5 自定义方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中通常我们是建立类似StringUtils这种的通用类库，想要在String类中增加一些自定义的方法要怎么做？Java中是无法办到的，在Scala 2.1.0中可以定义隐式转换的类，在这个类中定义自己的方法来实现期望的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">StringImprovement</span>(<span class="params">s:<span class="type">String</span></span>) </span>&#123;</span><br><span class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">increment</span> </span>= s.map(c =&gt; (c.toByte + <span class="number">1</span>).toChar)</span><br><span class="line">     | &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">StringImprovement</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> "<span class="title">abc</span>".<span class="title">increment</span></span></span><br><span class="line"><span class="class"><span class="title">res16</span></span>: <span class="type">String</span> = bcd</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以任务String调用的方法都不奇怪，可能某处引用的包中定义了某个隐式转换的类及自定义方法。在Scala2.1.0之前的版本，若想要实现这样的功能，需要定义一个隐式转换的方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;  <span class="class"><span class="keyword">class</span> <span class="title">StringImprovement</span>(<span class="params">s:<span class="type">String</span></span>) </span>&#123;</span><br><span class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">increment</span> </span>= s.map(c =&gt; (c.toByte + <span class="number">1</span>).toChar)</span><br><span class="line">     | &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">StringImprovement</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">implicit</span> <span class="title">def</span> <span class="title">stringToString</span>(<span class="params">s:<span class="type">String</span></span>) </span>= <span class="keyword">new</span> <span class="type">StringImprovement</span>(s)</span><br><span class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</span><br><span class="line">stringToString: (s: <span class="type">String</span>)<span class="type">StringImprovement</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="string">"abc"</span>.increment</span><br><span class="line">res0: <span class="type">String</span> = bcd</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，在Scala中可以创建一个隐式转换的类，将他们引入需要的范围中去，而不需要进行继承，定义一个MyXxxx的新类。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面简要描述下其工作原理：</p><ol><li>编译器找到”abc”的字符串常量</li><li>编译器发现要在String调用increment方法</li><li>因为String类中没有increment方法，它开始在当前范围内搜索一个接受String作为参数的隐式转换。</li><li>如此编译器会找到StringImprovement类，在这个类中找到了increment方法</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上文中已经介绍了Scala语言中的基本类型，本文着重介绍下字符串的用法，字符串在我们日常开发中经常用到，字符串在Scala中的类型&lt;code&gt;String&lt;/code&gt;，那么Scala中的String和Java中的String有什么关系呢？&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;Scala&quot;&lt;/span&gt;.getClass.getName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;res0: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; = java.lang.&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本以为Scala是怎样实现了String，上述代码中告诉我们Scala中的&lt;code&gt;String&lt;/code&gt;竟就是Java中的&lt;code&gt;String&lt;/code&gt;。我们接下更深层次的学习&lt;code&gt;String&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;/images/a311e33c02d299ee621f10649459ac73.png&quot; alt=&quot;a311e33c02d299ee621f10649459ac73&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x01 一起来学Scala" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x01-%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Scala/"/>
    
    
      <category term="Scala" scheme="http://deletee.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>一起来学Scala(2)-基本类型</title>
    <link href="http://deletee.top/2019/01/09/scala-programing-basictype/"/>
    <id>http://deletee.top/2019/01/09/scala-programing-basictype/</id>
    <published>2019-01-09T13:28:50.000Z</published>
    <updated>2019-01-26T13:16:31.779Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文中已经介绍了Scala语言的入门概要，本文将介绍Scala的基本语法，Scala中有变量、对象、类、方法，在面向对象方面Scala与Java很像，在代码编写风格与Python又很像，除此之外，大家也会碰到一些未曾接触的语法，例如 _  . 等，本文将逐步介绍这些概念。</p><a id="more"></a><h4 id="0x0-基本类型"><a href="#0x0-基本类型" class="headerlink" title="0x0 基本类型"></a>0x0 基本类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们了解Scala中有哪些基本类型：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>Byte</td><td>8位有符号补码整数。数值区间为 -128 到 127</td></tr><tr><td>Short</td><td>16位有符号补码整数。数值区间为 -32768 到 32767</td></tr><tr><td>Int</td><td>32位有符号补码整数。数值区间为 -2147483648 到 2147483647</td></tr><tr><td>Long</td><td>64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td></tr><tr><td>Float</td><td>32 位, IEEE 754 标准的单精度浮点数</td></tr><tr><td>Double</td><td>64 位 IEEE 754 标准的双精度浮点数</td></tr><tr><td>Char</td><td>16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF</td></tr><tr><td>String</td><td>字符序列</td></tr><tr><td>Boolean</td><td>true或false</td></tr><tr><td>Unit</td><td>表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</td></tr><tr><td>Null</td><td>null 或空引用</td></tr><tr><td>Nothing</td><td>Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。</td></tr><tr><td>Any</td><td>Any是所有其他类的超类</td></tr><tr><td>AnyRef</td><td>AnyRef类是Scala里所有引用类(reference class)的基类</td></tr></tbody></table></div><p>(摘自<a href="http://www.runoob.com/scala/scala-data-types.html" target="_blank" rel="noopener">Scala基本类型</a>)</p><p>下图展示了基本类型之间的拓扑关系图，Scala中一切皆对象：</p><p><img src="/images/091419398321557.png" alt="091419398321557"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str:<span class="type">String</span> = <span class="string">"Hello Scala"</span></span><br><span class="line"><span class="keyword">var</span> i:<span class="type">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>上述实例中声明了变量str类型是String型，变量值为”Hello Scala”<br>当为变量分配初始值时，Scala编译器可以根据分配给它的值来推断变量的类型。这被称为变量类型推断。 因此，可以编写这样的变量声明 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">"Hello Scala"</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br></pre></td></tr></table></figure><!--未完待续--><h4 id="0x1-声明变量"><a href="#0x1-声明变量" class="headerlink" title="0x1 声明变量"></a>0x1 声明变量</h4><h5 id="0x10-声明关键字-val-var"><a href="#0x10-声明关键字-val-var" class="headerlink" title="0x10 声明关键字: val,var"></a><strong>0x10 声明关键字</strong>: val,var</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>val</code> 用于定义常量，相当于Java中使用final定义一样，<code>val</code>  是value的缩写<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>var</code> 用于定义变量，<code>val</code> 是variable的缩写<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Scala语言中，使用val定义的变量，是不能够重新赋值的，而var定义的变量是可以重新进行赋值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> str = <span class="string">"Hello World"</span></span><br><span class="line">str: <span class="type">String</span> = <span class="type">Hello</span> <span class="type">World</span></span><br><span class="line"></span><br><span class="line">scala&gt; str = <span class="string">"Hello Scala"</span></span><br><span class="line">&lt;console&gt;:<span class="number">12</span>: error: reassignment to <span class="keyword">val</span></span><br><span class="line">       str = <span class="string">"Hello Scala"</span></span><br><span class="line">           ^</span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> str = <span class="string">"Hello World"</span></span><br><span class="line">str: <span class="type">String</span> = <span class="type">Hello</span> <span class="type">World</span></span><br><span class="line"></span><br><span class="line">scala&gt; str = <span class="string">"Hello Scala"</span></span><br><span class="line">str: <span class="type">String</span> = <span class="type">Hello</span> <span class="type">Scala</span></span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><h5 id="0x11-多个赋值"><a href="#0x11-多个赋值" class="headerlink" title="0x11 多个赋值"></a>0x11 多个赋值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scala支持多个赋值。如果代码块或方法返回一个元组(Tuple - 保持不同类型的对象的集合)，则可以将元组分配给一个<code>val</code>变量。</p><blockquote><p>注：我们将在随后的章节学习元组。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (myVar1: <span class="type">Int</span>, myVar2: <span class="type">String</span>) = <span class="type">Pair</span>(<span class="number">40</span>, <span class="string">"Foo"</span>)</span><br><span class="line"><span class="type">Scala</span></span><br></pre></td></tr></table></figure><p>类型推断得到正确的类型 -</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (myVar1, myVar2) = <span class="type">Pair</span>(<span class="number">40</span>, <span class="string">"Foo"</span>)</span><br></pre></td></tr></table></figure><h4 id="0x2-变量的作用域"><a href="#0x2-变量的作用域" class="headerlink" title="0x2 变量的作用域"></a>0x2 变量的作用域</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scala中变量同其他语言类似，有不同的作用域，具体取决于它们被使用的位置。它们可以作为字段存在，作为方法参数和局部变量存在。以下是每种类型范围的详细信息。</p><h5 id="0x20-字段"><a href="#0x20-字段" class="headerlink" title="0x20 字段"></a><strong>0x20 字段</strong></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明为对象中的字段信息，那么根据需要可使用<code>val</code>或者<code>var</code>，对象中的字段可以被对象中其他方法访问，配合访问修饰符，可以设置外部变量或者对象访问</p><h5 id="0x21-方法参数"><a href="#0x21-方法参数" class="headerlink" title="0x21 方法参数"></a><strong>0x21 方法参数</strong></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法或函数入参都是常量，所以定义函数时都是使用<code>val</code>关键字定义，方法的参数是不可变的。</p><h5 id="0x22-局部变量"><a href="#0x22-局部变量" class="headerlink" title="0x22 局部变量"></a><strong>0x22 局部变量</strong></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;局部变量是在方法中声明的变量。局部变量只能从方法内部访问，但如果从方法返回，则您创建的对象可能会转义该方法。局部变量可以是可变的和不可变的类型，可以使用<code>var</code>或<code>val</code>定义。</p><h4 id="0xF-总结"><a href="#0xF-总结" class="headerlink" title="0xF 总结"></a>0xF 总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要介绍了Scala中基本数据类型及变量的声明方法，根据需要选择合适的关键字进行变量定义。<code>var</code> 修饰的对象引用可以改变，<code>val</code>修饰的则不可改变，但对象的状态却是可以改变的，即表示对于一个对象，通过 val 初始化对象后，该对象是不能够改变的，但是如果对象中有<code>var</code>声明的字段，那么是可以修改对象字段值，实现对象状态的改变。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">n: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">n: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> value = <span class="keyword">new</span> <span class="type">A</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">B</span>(<span class="number">5</span>)</span><br><span class="line">    x = <span class="keyword">new</span> <span class="type">B</span>(<span class="number">6</span>) <span class="comment">// 错误，因为 x 为 val 修饰的，引用不可改变</span></span><br><span class="line">    x.value = <span class="keyword">new</span> <span class="type">A</span>(<span class="number">6</span>) <span class="comment">// 错误，因为 x.value 为 val 修饰的，引用不可改变</span></span><br><span class="line">    x.value.value = <span class="number">6</span> <span class="comment">// 正确，x.value.value 为var 修饰的，可以重新赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------- </span></span><br><span class="line"><span class="comment">// 作者：GuaKin_Huang </span></span><br><span class="line"><span class="comment">// 来源：CSDN </span></span><br><span class="line"><span class="comment">// 原文：https://blog.csdn.net/a1234h/article/details/77962536 </span></span><br><span class="line"><span class="comment">// 版权声明：本文为博主原创文章，转载请附上博文链接！</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上文中已经介绍了Scala语言的入门概要，本文将介绍Scala的基本语法，Scala中有变量、对象、类、方法，在面向对象方面Scala与Java很像，在代码编写风格与Python又很像，除此之外，大家也会碰到一些未曾接触的语法，例如 _  . 等，本文将逐步介绍这些概念。&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x01 一起来学Scala" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x01-%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Scala/"/>
    
    
      <category term="Scala" scheme="http://deletee.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>常用的一些SQL语句</title>
    <link href="http://deletee.top/2019/01/09/useful-sql/"/>
    <id>http://deletee.top/2019/01/09/useful-sql/</id>
    <published>2019-01-09T13:05:30.000Z</published>
    <updated>2019-01-26T13:17:04.416Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际工作过程中，经常用的几个SQL，常常因为某些关键字忘记，从而经常需要找工具书或者之前做的工程，本文将自己工作中常常容易忘记的SQL整理出来，方便直接定位。</p><h4 id="0x0-建表DDL-指定分隔符、分区"><a href="#0x0-建表DDL-指定分隔符、分区" class="headerlink" title="0x0 建表DDL(指定分隔符、分区)"></a>0x0 建表DDL(指定分隔符、分区)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dim.dim_sms_rate_standard</span><br><span class="line">(</span><br><span class="line">     contry_code <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">'国家码'</span></span><br><span class="line">    ,contry_en_name <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">'国家英文名'</span></span><br><span class="line">    ,contry_brief_name <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">'国家简码'</span></span><br><span class="line">    ,sms_price <span class="built_in">float</span> <span class="keyword">comment</span> <span class="string">'短信单价'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> </span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">partition</span>(dt <span class="keyword">string</span> <span class="keyword">comment</span> <span class="string">'日期'</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="0x1-设置压缩格式"><a href="#0x1-设置压缩格式" class="headerlink" title="0x1 设置压缩格式"></a>0x1 设置压缩格式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.compress.output=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> mapred.output.compression.codec=com.hadoop.compression.lzo.LzopCodec;</span><br></pre></td></tr></table></figure><h4 id="0x2-查看外表分区路径"><a href="#0x2-查看外表分区路径" class="headerlink" title="0x2 查看外表分区路径"></a>0x2 查看外表分区路径</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc formatted dim.dim_sms_rate_standard partition(dt='2019-01-08');</span><br></pre></td></tr></table></figure><h4 id="0x3-动态分区"><a href="#0x3-动态分区" class="headerlink" title="0x3 动态分区"></a>0x3 动态分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode=nonstrict; </span><br><span class="line"><span class="keyword">SET</span> hive.exec.max.dynamic.partitions=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.max.dynamic.partitions.pernode=<span class="number">100000</span>;</span><br></pre></td></tr></table></figure><h4 id="0xF-未完待续"><a href="#0xF-未完待续" class="headerlink" title="0xF 未完待续"></a>0xF 未完待续</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;实际工作过程中，经常用的几个SQL，常常因为某些关键字忘记，从而经常需要找工具书或者之前做的工程，本文将自己工作中常常容易忘记的SQL整理出来，方便直接定位。&lt;/p&gt;
&lt;h4 id=&quot;0x0-建表DDL-指定分隔符、分区&quot;&gt;&lt;a href=&quot;#0x0-建表DDL-指定分隔符、分区&quot; class=&quot;headerlink&quot; title=&quot;0x0 建表DDL(指定分隔符、分区)&quot;&gt;&lt;/a&gt;0x0 建表DDL(指定分隔符、分区)&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; dim.dim_sms_rate_standard&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     contry_code &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;国家码&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ,contry_en_name &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;国家英文名&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ,contry_brief_name &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;国家简码&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ,sms_price &lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;短信单价&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;delimited&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;partition&lt;/span&gt;(dt &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;日期&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x2 技术平台" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="1x21 Hive" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x2-%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/1x21-Hive/"/>
    
    
      <category term="Hive" scheme="http://deletee.top/tags/Hive/"/>
    
      <category term="SQL" scheme="http://deletee.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>一起来学Scala(1)-入门概要</title>
    <link href="http://deletee.top/2019/01/07/scala-programing-brief/"/>
    <id>http://deletee.top/2019/01/07/scala-programing-brief/</id>
    <published>2019-01-07T14:35:50.000Z</published>
    <updated>2019-01-26T13:16:38.276Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要学Scala？Scala是大数据分析平台Spark、Flink 官方支持的语言，在学习Spark和Flink之前，需要学好Scala基础。Scala同样是一门当前热门的语言，Kafka、Spark均由Scala开发，由此学习Scala是学习这些平台比不可少的步骤。</p><p><img src="/images/a311e33c02d299ee621f10649459ac73.png" alt="a311e33c02d299ee621f10649459ac73"></p><a id="more"></a><h3 id="0x0-Scala基本定义"><a href="#0x0-Scala基本定义" class="headerlink" title="0x0 Scala基本定义"></a>0x0 Scala基本定义</h3><p>Scala 是一门多范式（multi-paradigm）的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。<br>Scala 运行在Java虚拟机上，并兼容现有的Java程序。<br>Scala 源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库，由而Java同样可以调用Scala的类库。Scala语言 使用 JDK &amp; Scala SDK </p><h3 id="0x1-Scala的运行方式"><a href="#0x1-Scala的运行方式" class="headerlink" title="0x1 Scala的运行方式"></a>0x1 Scala的运行方式</h3><p>开发Scala程序之前需要安装<a href="https://www.scala-lang.org/" target="_blank" rel="noopener">Scala</a> </p><h4 id="0x10-脚本运行"><a href="#0x10-脚本运行" class="headerlink" title="0x10 脚本运行"></a>0x10 脚本运行</h4><p>Scala也是一种脚本式语言，可以将Scala程序写入一个脚本，直接执行</p><p>如下是第一个 Scala程序:HelloWorld.scala</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">        println(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$:scala HelloWorld.scala</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h4 id="0x11-编译执行"><a href="#0x11-编译执行" class="headerlink" title="0x11 编译执行"></a>0x11 编译执行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$:scalac HelloWorld.scala</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将会得到如下两个 class文件，即为 Java字节码</span></span><br><span class="line">HewlloWorld$.class</span><br><span class="line">HewlloWorld.class</span><br></pre></td></tr></table></figure><p>执行方式与执行javaclass类同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$:scala HelloWorld</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h3 id="0xF-总结"><a href="#0xF-总结" class="headerlink" title="0xF 总结"></a>0xF 总结</h3><p>Scala 的语法相对Python而言是比较晦涩，后续尽量以简单清晰的实例，从而达到更好的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么要学Scala？Scala是大数据分析平台Spark、Flink 官方支持的语言，在学习Spark和Flink之前，需要学好Scala基础。Scala同样是一门当前热门的语言，Kafka、Spark均由Scala开发，由此学习Scala是学习这些平台比不可少的步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/a311e33c02d299ee621f10649459ac73.png&quot; alt=&quot;a311e33c02d299ee621f10649459ac73&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x01 一起来学Scala" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x01-%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Scala/"/>
    
    
      <category term="Scala" scheme="http://deletee.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>awk的基本使用方法</title>
    <link href="http://deletee.top/2019/01/06/awk-basic/"/>
    <id>http://deletee.top/2019/01/06/awk-basic/</id>
    <published>2019-01-06T07:46:30.000Z</published>
    <updated>2019-01-27T14:58:15.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0-简介"><a href="#0x0-简介" class="headerlink" title="0x0 简介"></a><strong>0x0 简介</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p><h3 id="0x1-使用方法"><a href="#0x1-使用方法" class="headerlink" title="0x1 使用方法"></a>0x1 使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;pattern + action&#125;' &#123;filenames&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。awk 有如下三种使用方式</p><h4 id="0x10-命令行方式"><a href="#0x10-命令行方式" class="headerlink" title="0x10 命令行方式"></a>0x10 命令行方式</h4><figure class="highlight shell"><figcaption><span>awk [-F field-separatir] 'commands' input-file </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [-F field-separatir] 'commands' input-file</span><br></pre></td></tr></table></figure><p>此种方式为最常用的一种方式，-F 是将文件按指定分隔符进行切割。</p><h4 id="0x11-shell脚本方式"><a href="#0x11-shell脚本方式" class="headerlink" title="0x11 shell脚本方式"></a>0x11 shell脚本方式</h4><p>将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。<br>相当于shell脚本首行的：#!/bin/sh<br>可以换成：#!/bin/awk</p><h4 id="0x12-将所有的awk命令插入一个单独文件，然后调用："><a href="#0x12-将所有的awk命令插入一个单独文件，然后调用：" class="headerlink" title="0x12 将所有的awk命令插入一个单独文件，然后调用："></a>0x12 将所有的awk命令插入一个单独文件，然后调用：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f awk-script-file input-file(s)</span><br></pre></td></tr></table></figure><p>其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</p><h3 id="0x2-入门实例"><a href="#0x2-入门实例" class="headerlink" title="0x2 入门实例"></a>0x2 入门实例</h3><h4 id="0x20-分隔符"><a href="#0x20-分隔符" class="headerlink" title="0x20 分隔符"></a>0x20 分隔符</h4><p>例如：a.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>awk 默认支持分隔符，例如 空格，制表符，如下两种方式等价</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F&apos; &apos; &apos;&#123;print $1&#125;&apos; a.txt</span><br><span class="line">awk &apos;&#123;print $1&#125;&apos; a.txt</span><br></pre></td></tr></table></figure><p>$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。</p><p>例如： b.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2,3</span><br><span class="line">3,4,5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -F&apos;,&apos; &apos;&#123;print $1&#125;&apos;</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="0x21-BEGIN-amp-END"><a href="#0x21-BEGIN-amp-END" class="headerlink" title="0x21  BEGIN &amp; END"></a>0x21  BEGIN &amp; END</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd \</span><br><span class="line">|awk  -F ':'  'BEGIN &#123;print "name,shell"&#125;  &#123;print $1","$7&#125; END &#123;print "blue,/bin/nosh"&#125;'</span><br><span class="line">name,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">daemon,/bin/sh</span><br><span class="line">bin,/bin/sh</span><br><span class="line">sys,/bin/sh</span><br><span class="line">....</span><br><span class="line">blue,/bin/nosh</span><br></pre></td></tr></table></figure><p>BEGIN 是在处理数据行之前进行的操作</p><p>END 则是在数据行处理之后进行的操作</p><p>例如：c.txt 求第一列的总和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,2,3</span><br><span class="line">3,4,5</span><br><span class="line">4,5,6</span><br><span class="line">7,8,9</span><br></pre></td></tr></table></figure><p><strong>命令如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">','</span> <span class="string">'BEGIN &#123;sum=0&#125; sum+=$1 END &#123;print "sum = "sum&#125;'</span></span><br></pre></td></tr></table></figure><p>BEGIN 声明一个sum 初始化值为0 的变量，END 将变量输出</p><h3 id="0x3-awk内置变量"><a href="#0x3-awk内置变量" class="headerlink" title="0x3 awk内置变量"></a>0x3 awk内置变量</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ARGC               命令行参数个数</span><br><span class="line">ARGV               命令行参数排列</span><br><span class="line">ENVIRON            支持队列中系统环境变量的使用</span><br><span class="line">FILENAME           awk浏览的文件名</span><br><span class="line">FNR                浏览文件的记录数</span><br><span class="line">FS                 设置输入域分隔符，等价于命令行 -F选项</span><br><span class="line">NF                 浏览记录的域的个数</span><br><span class="line">NR                 已读的记录数</span><br><span class="line">OFS                输出域分隔符</span><br><span class="line">ORS                输出记录分隔符</span><br><span class="line">RS                 控制记录分隔符</span><br></pre></td></tr></table></figure><h3 id="0x4-awk-编程"><a href="#0x4-awk-编程" class="headerlink" title="0x4 awk 编程"></a>0x4 awk 编程</h3><p>awk 可在内部实现丰富的编程</p><p><strong>条件语句</strong></p><p> awk中的条件语句是从C语言中借鉴来的，见如下声明方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (expression) &#123;</span><br><span class="line">    statement;</span><br><span class="line">    statement;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (expression) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (expression) &#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125; else if (expression1) &#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    statement3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l |awk 'BEGIN &#123;size=0;print "[start]size is ", size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print "[end]size is ", size/1024/1024,"M"&#125;' </span><br><span class="line">[end]size is  8.22339 M</span><br></pre></td></tr></table></figure><p><strong>循环语句</strong></p><p>awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。</p><p><strong>数组</strong></p><p>  因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk -F ':' 'BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;' /etc/passwd</span><br><span class="line">0 root</span><br><span class="line">1 daemon</span><br><span class="line">2 bin</span><br><span class="line">3 sys</span><br><span class="line">4 sync</span><br><span class="line">5 games</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>awk编程的内容极多，这里只罗列简单常用的用法，更多请参考：<a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">gawk</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0-简介&quot;&gt;&lt;a href=&quot;#0x0-简介&quot; class=&quot;headerlink&quot; title=&quot;0x0 简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;0x0 简介&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。&lt;br&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x00 一起来学Shell" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x00-%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Shell/"/>
    
    
      <category term="shell" scheme="http://deletee.top/tags/shell/"/>
    
      <category term="awk" scheme="http://deletee.top/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库工程师学习路线</title>
    <link href="http://deletee.top/2019/01/05/edw-need-learning/"/>
    <id>http://deletee.top/2019/01/05/edw-need-learning/</id>
    <published>2019-01-05T07:46:30.000Z</published>
    <updated>2019-11-23T15:23:07.361Z</updated>
    
    <content type="html"><![CDATA[<p>刚看了木东居士关于《<a href="http://www.mdjs.info/2018/10/26/learn-for-resume/#more" target="_blank" rel="noopener">聊一聊如何面向简历学习</a>》，有一些感触，每每思考到职业发展总是有一种恐慌，因为我们很多时候都忘了梦想，甚至根本没有梦想，也就谈不上规划，今天是思考和整理下自己的学习路线。写下自己的想法及规划。</p><blockquote><p>你是否担心互联网寒冬中首先淘汰的那波人就有自己？你是否感觉到自己缺乏核心竞争力？是否感觉已经很久没有学习成长？</p></blockquote><a id="more"></a><p>&nbsp; &nbsp; &nbsp; &nbsp;一个数据仓库工程师或者数据开发人员，需要掌握什么技能？数据仓库应该分为四类：建模方法论，实施方法论、数据管理方法论、数据应用，所以我们将木东居士的内容整理了一下，如下：</p><div class="table-container"><table><thead><tr><th>主题</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>数据建模</td><td>常用数据仓库模型原理总结</td><td>1 周</td></tr><tr><td>数据建模</td><td>维度建模原理</td><td>1 周</td></tr><tr><td>数据建模</td><td>以淘宝的场景为例设计一套数据模型</td><td>1 周</td></tr><tr><td>数据建模</td><td>时间维表设计</td><td>1 周</td></tr><tr><td>数据管理</td><td>元数据管理</td><td>1 周</td></tr><tr><td>数据管理</td><td>数据质量监控设计</td><td>1 周</td></tr><tr><td>数据管理</td><td>数据血缘分析</td><td>1 周</td></tr><tr><td>数据管理</td><td>作业监控设计</td><td>1 周</td></tr><tr><td>数据应用</td><td>OLap分析原理+Kylin实践</td><td>3 周</td></tr><tr><td>数据应用</td><td>数据分层设计</td><td>1 周</td></tr><tr><td>大数据平台</td><td>Hive（基本用法、高阶函数用法、Hive优化）</td><td>2 周</td></tr><tr><td>大数据平台</td><td>Hive 执行过程原理</td><td>1 周</td></tr><tr><td>大数据平台</td><td>Hadoop 常用命令</td><td>1 周</td></tr><tr><td>大数据平台</td><td>HBase 基本用法，原理</td><td>2 周</td></tr><tr><td>大数据平台</td><td>Spark 常用命令</td><td>1 周</td></tr><tr><td>大数据平台</td><td>Flink 基本用法，原理</td><td>2 周</td></tr><tr><td>大数据平台</td><td>Kafka 基本用法，原理</td><td>2 周</td></tr><tr><td>脚本语言</td><td>Python</td><td>2 周</td></tr><tr><td>脚本语言</td><td>Scala</td><td>2 周</td></tr><tr><td>论文阅读</td><td>Google 的 Goods 论文阅读（数据管理）</td><td>1 周</td></tr></tbody></table></div><p>在日常工作中，并不是所有技术都有在使用，往往没有使用的技术或方法论，则容易被我们忘记，所以最好的方式，就是写博客或者写PPT，以自己理解的话术表达出来，相信这样的模式会比单纯的记忆一些概念要好很多。</p><p>感谢@木东居士的分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚看了木东居士关于《&lt;a href=&quot;http://www.mdjs.info/2018/10/26/learn-for-resume/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;聊一聊如何面向简历学习&lt;/a&gt;》，有一些感触，每每思考到职业发展总是有一种恐慌，因为我们很多时候都忘了梦想，甚至根本没有梦想，也就谈不上规划，今天是思考和整理下自己的学习路线。写下自己的想法及规划。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你是否担心互联网寒冬中首先淘汰的那波人就有自己？你是否感觉到自己缺乏核心竞争力？是否感觉已经很久没有学习成长？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x1 数据仓库" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
      <category term="1x12 综合" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/1x12-%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="数据仓库" scheme="http://deletee.top/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
      <category term="学习" scheme="http://deletee.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>awk的高级应用-多目录输出</title>
    <link href="http://deletee.top/2018/12/31/awk-application/"/>
    <id>http://deletee.top/2018/12/31/awk-application/</id>
    <published>2018-12-31T07:46:30.000Z</published>
    <updated>2019-01-26T13:14:31.891Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk是Shell中三剑客之一，功能十分强大，本文分享的通过一份管道输入，实现多目录输出。原理：awk内部可实现编程，在awk内部将输入流进行预处理后，利用 print ${content} &gt;&gt; ${path}的方式将数据进行分流。</p><p><strong>下面一个实例：</strong></p><blockquote><p>通过HDFS 标准输入流，在awk中根据数据日期时间分流至不同的日期文件夹中。</p></blockquote><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">#***********************************************************************</span></span><br><span class="line"><span class="comment">#脚本功能: 追补历史推送数据</span></span><br><span class="line"><span class="comment">#创建日期: 2016-05-16</span></span><br><span class="line"><span class="comment">#修改纪录：      修改人            修改日期          修改描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----+-----------------+--------------------+--------------------------+</span></span><br><span class="line"><span class="comment">#  1          deletee       2017-10-12            创建</span></span><br><span class="line"><span class="comment">#***********************************************************************</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量设置</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------</span></span><br><span class="line"><span class="comment"># JOB_HOME：作业目录</span></span><br><span class="line"><span class="comment"># HDFS_PATH :HDFS目录</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Local</span></span><br><span class="line">JOB_HOME=$(<span class="built_in">cd</span> <span class="string">"<span class="variable">$(dirname "$0")</span>"</span>; <span class="built_in">pwd</span>)</span><br><span class="line">JOB_DATA_PATH=<span class="variable">$&#123;JOB_HOME&#125;</span>/data</span><br><span class="line">PROCESSED_FILE_PATH=<span class="variable">$&#123;JOB_HOME&#125;</span>/pro</span><br><span class="line">SECRETS_CONF_PATH=<span class="variable">$&#123;JOB_HOME&#125;</span>/conf</span><br><span class="line">mkdir -p <span class="variable">$&#123;JOB_HOME&#125;</span>/&#123;data,pro,conf&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># HDFS</span></span><br><span class="line">HADOOP_HOME=/home/<span class="variable">$&#123;USER&#125;</span>/software/hadoop</span><br><span class="line">HDFS_PATH=/hdfs/*/some_log/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------</span></span><br><span class="line"><span class="comment"># 函数名:genTargetFileModel</span></span><br><span class="line"><span class="comment"># 功能:生成目标文件模式,遍历HDFS目录，生成日、时、分</span></span><br><span class="line"><span class="comment"># 参数: $1 日期，格式 yyyy-MM-dd</span></span><br><span class="line"><span class="comment"># 返回:无</span></span><br><span class="line"><span class="comment">#---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">genTargetFileModel</span></span>() &#123;</span><br><span class="line">      <span class="comment"># 遍历日期</span></span><br><span class="line">      ETL_DT=<span class="variable">$1</span></span><br><span class="line">      CUR_HDFS_PATH=`<span class="built_in">echo</span> <span class="variable">$&#123;HDFS_PATH&#125;</span>|sed <span class="string">"s:*:<span class="variable">$&#123;ETL_DT&#125;</span>:"</span>`</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (( i = 0; i &lt; 24; i++ )); <span class="keyword">do</span></span><br><span class="line">          <span class="keyword">for</span> (( j = 0; j &lt; 12; j++ )); <span class="keyword">do</span></span><br><span class="line">              hour=`<span class="built_in">printf</span> <span class="string">"%02d"</span> <span class="variable">$i</span>`</span><br><span class="line">              minutes=$((j*5))</span><br><span class="line">              minutes=`<span class="built_in">printf</span> <span class="string">"%02d"</span> <span class="variable">$minutes</span>`</span><br><span class="line">              mkdir -p <span class="variable">$&#123;JOB_DATA_PATH&#125;</span>/<span class="variable">$&#123;ETL_DT&#125;</span>/<span class="variable">$&#123;hour&#125;</span>/<span class="variable">$&#123;minutes&#125;</span></span><br><span class="line">          <span class="keyword">done</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> path <span class="keyword">in</span> `<span class="variable">$&#123;HADOOP_HOME&#125;</span>/bin/hadoop fs -ls <span class="variable">$&#123;CUR_HDFS_PATH&#125;</span> \</span><br><span class="line">      |awk <span class="string">'&#123;print $8&#125;'</span>`;<span class="keyword">do</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;ETL_DT&#125;</span>:<span class="variable">$&#123;path&#125;</span>"</span> &gt;&gt; <span class="variable">$&#123;PROCESSED_FILE_PATH&#125;</span>/pro_<span class="variable">$&#123;ETL_DT&#125;</span>.txt</span><br><span class="line">          <span class="variable">$&#123;HADOOP_HOME&#125;</span>/bin/hadoop fs -text <span class="variable">$&#123;path&#125;</span> |awk <span class="string">'&#123;</span></span><br><span class="line"><span class="string">              split($0,a," ");</span></span><br><span class="line"><span class="string">              datestr=substr(a[1],11,10);</span></span><br><span class="line"><span class="string">              hourstr=substr(a[2],1,2);</span></span><br><span class="line"><span class="string">              minutestr=substr(a[2],4,2);</span></span><br><span class="line"><span class="string">              minutestr=int(minutestr/5)*5;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              if(minutestr&lt;10)&#123;</span></span><br><span class="line"><span class="string">                minutestr=("0"minutestr)</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              gsub("\"","",a[3])</span></span><br><span class="line"><span class="string">              split(a[3],b,",");</span></span><br><span class="line"><span class="string">              gsub("&#123;|&#125;","",b[3])</span></span><br><span class="line"><span class="string">              gsub("fields:HOSTNAME:","",b[3])</span></span><br><span class="line"><span class="string">              gsub("\\\\t","\t",b[1])</span></span><br><span class="line"><span class="string">              gsub(";","\t",b[1])</span></span><br><span class="line"><span class="string">              lens=split(b[1],tA,"\t")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              if(lens==12)&#123;</span></span><br><span class="line"><span class="string">                re=(b[1]"\t\t\t\t\t\t\t\t\t\t\t\t"b[3])</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">              if(lens==15)&#123;</span></span><br><span class="line"><span class="string">                re=(b[1]"\t\t\t\t\t\t\t\t\t"b[3])</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">              path=(datestr"/"hourstr"/"minutestr"/log_"datestr"_"hourstr"_"minutestr".txt")</span></span><br><span class="line"><span class="string">              print re &gt;&gt; path</span></span><br><span class="line"><span class="string">          &#125;'</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">      <span class="built_in">unset</span> ETL_DT</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------</span></span><br><span class="line"><span class="comment"># 函数名:genTargetFileModel</span></span><br><span class="line"><span class="comment"># 功能:生成目标文件模式,遍历HDFS目录，生成日、时、分</span></span><br><span class="line"><span class="comment"># 参数: $1 日期，格式 yyyy-MM-dd</span></span><br><span class="line"><span class="comment"># 返回:无</span></span><br><span class="line"><span class="comment">#---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sendByRysnc</span></span>() &#123;</span><br><span class="line">  ETL_DT=<span class="variable">$1</span></span><br><span class="line">  nohup /usr/bin/rsync -avz \</span><br><span class="line">        --bwlimit=30720 \</span><br><span class="line">        --port=873 \</span><br><span class="line">        --progress \</span><br><span class="line">        --password-file=<span class="variable">$&#123;SECRETS_CONF_PATH&#125;</span>/secret.conf <span class="variable">$&#123;JOB_DATA_PATH&#125;</span>/<span class="variable">$&#123;ETL_DT&#125;</span> <span class="variable">$&#123;user&#125;</span>@<span class="variable">$&#123;ip&#125;</span>::<span class="variable">$&#123;module&#125;</span>/<span class="variable">$&#123;path&#125;</span>/ &gt;&gt; rysnc_send_$(date +%Y%m%d).<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line">  <span class="built_in">unset</span> ETL_DT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">mainStart</span></span>() &#123;</span><br><span class="line">    ETL_DT=<span class="variable">$1</span></span><br><span class="line">    genTargetFileModel <span class="variable">$&#123;ETL_DT&#125;</span></span><br><span class="line">    sendByRysnc <span class="variable">$&#123;ETL_DT&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mainStart 2017-09-29</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;awk是Shell中三剑客之一，功能十分强大，本文分享的通过一份管道输入，实现多目录输出。原理：awk内部可实现编程，在awk内部将输入流进行预处理后，利用 print ${content} &amp;gt;&amp;gt; ${path}的方式将数据进行分流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面一个实例：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过HDFS 标准输入流，在awk中根据数据日期时间分流至不同的日期文件夹中。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="1x 技术综合篇" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/"/>
    
      <category term="1x0 开发语言" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="1x00 一起来学Shell" scheme="http://deletee.top/categories/1x-%E6%8A%80%E6%9C%AF%E7%BB%BC%E5%90%88%E7%AF%87/1x0-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/1x00-%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%AD%A6Shell/"/>
    
    
      <category term="shell" scheme="http://deletee.top/tags/shell/"/>
    
      <category term="awk" scheme="http://deletee.top/tags/awk/"/>
    
  </entry>
  
</feed>
